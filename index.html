<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>âœï¸ æˆé•¿æ‰‹è´¦ | æ™ºèƒ½åŒæ­¥ç‰ˆ</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- å¼•å…¥æ‰‹ç»˜é£æ ¼å­—ä½“ -->
    <link href="https://fonts.googleapis.com/css2?family=Gochi+Hand&family=Comic+Neue:wght@400;700&display=swap" rel="stylesheet">
    <!-- å¼•å…¥æ€ç»´å¯¼å›¾åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/@braintree/sanitize-html@2.7.2/dist/sanitize-html.min.js"></script>
    <style>
        /* ====== æ‰‹ç»˜é£æ ¼å…¨å±€æ ·å¼ ====== */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Comic Neue', cursive, -apple-system, sans-serif;
            background: #fef9f3 url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M11 18c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm48 25c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm-43-7c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm63 31c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM34 90c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm56-76c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM12 86c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm28-65c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm23-11c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-6 60c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm29 22c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zM32 63c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm57-13c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-9-21c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM60 91c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM35 41c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM12 60c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2z' fill='%23ffd6cc' fill-opacity='0.3' fill-rule='evenodd'/%3E%3C/svg%3E");
            min-height: 100vh;
            color: #5a4a42;
            padding: 20px;
            line-height: 1.6;
        }
        .container { max-width: 1400px; margin: 0 auto; }

        /* ====== æ‰‹ç»˜æ ‡é¢˜ä¸å¯¼èˆª ====== */
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: #fffaf0;
            border-radius: 24px 24px 48px 24px;
            color: #5a4a42;
            box-shadow: 8px 8px 0px #e0c9b8, 12px 12px 15px rgba(0, 0, 0, 0.05);
            border: 3px solid #5a4a42;
            position: relative;
        }
        .header::after {
            content: '';
            position: absolute;
            bottom: -10px;
            right: 30px;
            width: 120px;
            height: 10px;
            background: #ff9a8b;
            border-radius: 5px;
            opacity: 0.7;
        }
        .header h1 {
            font-size: 3.2em;
            margin-bottom: 10px;
            font-family: 'Gochi Hand', cursive;
            color: #5a4a42;
            text-shadow: 3px 3px 0px #ffd6cc;
            letter-spacing: 1px;
        }
        .header p {
            font-size: 1.2em;
            opacity: 0.9;
            max-width: 700px;
            margin: 0 auto;
        }

        /* ====== æ‰‹ç»˜ç½‘æ ¼å¸ƒå±€ ====== */
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 30px;
            margin-bottom: 40px;
        }

        /* ====== æ‰‹ç»˜å¡ç‰‡è®¾è®¡ ====== */
        .card {
            background: #fffefc;
            border-radius: 20px 8px 20px 8px;
            padding: 30px;
            box-shadow: 6px 6px 0px #d4b8a7, 10px 10px 20px rgba(0, 0, 0, 0.07);
            border: 2.5px solid #5a4a42;
            transition: all 0.3s ease;
            position: relative;
            overflow: visible;
        }
        .card::before {
            content: '';
            position: absolute;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            border: 1px dashed #ff9a8b;
            border-radius: 24px 10px 24px 10px;
            pointer-events: none;
            opacity: 0.6;
        }
        .card:hover {
            transform: translateY(-5px) rotate(0.5deg);
            box-shadow: 8px 8px 0px #c9a58f, 15px 15px 25px rgba(0, 0, 0, 0.09);
        }
        .card h2 {
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 3px dotted #ff9a8b;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            color: #5a4a42;
            font-size: 1.6em;
            font-family: 'Gochi Hand', cursive;
        }
        .card h2 .collapse-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 0.9em;
            color: #ff6b6b;
            padding: 5px 15px;
            border-radius: 20px;
            border: 2px solid #ff9a8b;
            background: #fffaf5;
            transition: all 0.3s;
            font-family: 'Comic Neue', cursive;
            font-weight: bold;
        }
        .card h2 .collapse-btn:hover {
            background: #ff9a8b;
            color: white;
            transform: scale(1.05);
        }

        /* ====== æ‰‹ç»˜ç©å®¶ç­‰çº§æ˜¾ç¤º ====== */
        .level-display {
            font-size: 5em;
            font-weight: 800;
            text-align: center;
            margin: 25px 0;
            font-family: 'Gochi Hand', cursive;
            color: #ff6b6b;
            text-shadow: 4px 4px 0px #ffd6cc, 8px 8px 8px rgba(0,0,0,0.1);
            letter-spacing: -2px;
            transform: rotate(-2deg);
        }
        .xp-progress {
            height: 26px;
            background: #ffe8d6;
            border-radius: 15px;
            margin: 20px 0;
            overflow: hidden;
            border: 2px solid #5a4a42;
            box-shadow: inset 3px 3px 5px rgba(0,0,0,0.1);
        }
        .xp-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #a3de83);
            border-radius: 13px;
            transition: width 0.7s ease;
            box-shadow: inset 2px 2px 4px rgba(255,255,255,0.5);
        }

        /* ====== æ‰‹ç»˜ä»»åŠ¡ä¸æŠ€èƒ½é¡¹ ====== */
        .skill-item {
            padding: 20px;
            background: #fffaf5;
            border-radius: 16px 8px 16px 8px;
            margin: 16px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s;
            border-left: 6px solid transparent;
            border: 2px solid #e0c9b8;
            position: relative;
        }
        .skill-item::before {
            content: 'â˜ï¸';
            position: absolute;
            top: -12px;
            right: 10px;
            font-size: 1.2em;
            opacity: 0.5;
        }
        .skill-item:hover {
            background: #fffef9;
            border-left-color: #ff9a8b;
            transform: translateX(5px);
        }
        .xp-badge {
            background: linear-gradient(45deg, #ff9a00, #ff5e00);
            color: white;
            padding: 6px 16px;
            border-radius: 20px 8px 20px 8px;
            font-size: 0.85em;
            font-weight: bold;
            margin-left: 10px;
            border: 1px solid #fff;
            box-shadow: 2px 2px 0px rgba(0,0,0,0.2);
        }

        /* ====== æ‰‹ç»˜æŒ‰é’®æ ·å¼ ====== */
        .btn {
            background: linear-gradient(90deg, #ff9a8b, #ff6b6b);
            border: none;
            padding: 16px 32px;
            border-radius: 50px 15px 50px 15px;
            color: white;
            cursor: pointer;
            font-size: 17px;
            font-weight: 700;
            font-family: 'Comic Neue', cursive;
            transition: all 0.3s;
            display: block;
            width: 100%;
            margin-top: 20px;
            box-shadow: 4px 4px 0px #d45d5d;
            letter-spacing: 0.5px;
            position: relative;
            overflow: hidden;
        }
        .btn:hover {
            transform: translateY(-3px) rotate(0.5deg);
            box-shadow: 6px 6px 0px #b84a4a;
        }
        .btn:active {
            transform: translateY(1px);
            box-shadow: 2px 2px 0px #d45d5d;
        }
        .btn-sm {
            padding: 10px 24px;
            font-size: 0.95em;
            width: auto;
            border-radius: 30px 8px 30px 8px;
            background: linear-gradient(90deg, #4ecdc4, #a3de83);
            box-shadow: 3px 3px 0px #2ba69b;
            border: none;
            color: white;
            font-weight: bold;
        }

        /* ====== æ‰‹ç»˜é…ç½®é¢æ¿ ====== */
        .config-panel {
            max-width: 600px;
            margin: 40px auto;
        }
        .config-info {
            padding: 20px;
            background: #fff9f0;
            border-radius: 15px;
            margin-bottom: 25px;
            font-size: 0.95em;
            border: 2px dashed #ffc8a3;
        }
        .config-info a {
            color: #ff6b6b;
            font-weight: bold;
            text-decoration: underline wavy;
        }

        /* ====== æ‰‹ç»˜ç¬”è®°ç³»ç»Ÿ ====== */
        .note-section {
            margin-top: 40px;
        }
        .note-tabs {
            display: flex;
            gap: 12px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        .note-tab {
            padding: 14px 32px;
            background: #fffaf5;
            border-radius: 40px 12px 40px 12px;
            cursor: pointer;
            font-weight: 700;
            transition: all 0.3s;
            border: 2px solid #e0c9b8;
            font-family: 'Comic Neue', cursive;
            color: #5a4a42;
        }
        .note-tab.active {
            background: linear-gradient(90deg, #a3de83, #4ecdc4);
            color: white;
            border-color: #2ba69b;
            box-shadow: 4px 4px 0px #2ba69b;
            transform: rotate(-0.5deg);
        }
        .note-editor {
            background: #fffefc;
            border-radius: 20px 10px 20px 10px;
            padding: 30px;
            box-shadow: 6px 6px 0px #d4b8a7;
            border: 2.5px solid #5a4a42;
            margin-bottom: 30px;
        }
        .note-input, .tag-input {
            width: 100%;
            padding: 18px;
            border: 2.5px solid #e0c9b8;
            border-radius: 15px 5px 15px 5px;
            font-size: 16px;
            font-family: 'Comic Neue', cursive;
            margin-bottom: 25px;
            transition: all 0.3s;
            background: #fffaf9;
        }
        .note-input:focus, .tag-input:focus {
            outline: none;
            border-color: #ff9a8b;
            box-shadow: 3px 3px 0px #ffd6cc;
            background: #fff;
        }
        .note-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 30px;
        }
        .note-card {
            background: #fffefc;
            border-radius: 20px 8px 20px 8px;
            padding: 30px;
            box-shadow: 6px 6px 0px #d4b8a7;
            border: 2.5px solid #5a4a42;
            position: relative;
        }
        .note-card::before {
            content: 'ğŸ“Œ';
            position: absolute;
            top: -15px;
            right: 20px;
            font-size: 1.5em;
            transform: rotate(15deg);
        }
        .note-tags { display: flex; gap: 10px; flex-wrap: wrap; margin: 20px 0; }
        .note-tag {
            background: rgba(255, 154, 139, 0.15);
            color: #d45d5d;
            padding: 6px 14px;
            border-radius: 20px 8px 20px 8px;
            font-size: 0.9em;
            font-weight: 700;
            border: 1.5px dashed #ff9a8b;
        }
        .note-image {
            max-width: 100%;
            max-height: 300px;
            border-radius: 15px 5px 15px 5px;
            margin-top: 20px;
            box-shadow: 4px 4px 0px #d4b8a7;
            border: 2px solid #5a4a42;
            display: block;
        }

        /* ====== æ‰‹ç»˜å›¾ç‰‡ä¸Šä¼ åŒºåŸŸ ====== */
        .image-upload-area {
            margin: 20px 0;
            padding: 25px;
            border: 3px dashed #ffc8a3;
            border-radius: 20px 8px 20px 8px;
            background: rgba(255, 248, 240, 0.7);
            text-align: center;
        }
        .image-preview {
            margin-top: 20px;
        }
        .image-preview img {
            max-width: 200px;
            max-height: 200px;
            border-radius: 15px 5px 15px 5px;
            border: 3px solid #ff9a8b;
            box-shadow: 4px 4px 0px #ffd6cc;
        }

        /* ====== æ‰‹ç»˜çŠ¶æ€æç¤º ====== */
        .status-message {
            padding: 15px 25px;
            border-radius: 15px 5px 15px 5px;
            margin: 20px 0;
            font-weight: 700;
            border: 2.5px solid;
            font-family: 'Comic Neue', cursive;
            box-shadow: 4px 4px 0px rgba(0,0,0,0.1);
        }
        .status-success {
            background: rgba(163, 222, 131, 0.95);
            color: #2d5a27;
            border-color: #2ba69b;
        }
        .status-error {
            background: rgba(255, 154, 139, 0.95);
            color: #7a2c28;
            border-color: #d45d5d;
        }
        .status-warning {
            background: rgba(255, 219, 153, 0.95);
            color: #8a5a29;
            border-color: #ffa94d;
        }

        /* ====== æ‰‹ç»˜ç»Ÿè®¡ä¿¡æ¯ ====== */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 25px;
            text-align: center;
            margin-top: 30px;
        }
        .stat-box {
            padding: 30px 20px;
            background: #fffefc;
            border-radius: 20px 8px 20px 8px;
            box-shadow: 5px 5px 0px #d4b8a7;
            border: 2.5px solid #5a4a42;
            transition: transform 0.3s;
        }
        .stat-box:hover {
            transform: translateY(-5px) rotate(0.5deg);
        }
        .stat-value {
            font-size: 3.2em;
            font-weight: 800;
            font-family: 'Gochi Hand', cursive;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            line-height: 1;
            text-shadow: 2px 2px 0px #ffd6cc;
        }
        .stat-label {
            margin-top: 15px;
            font-size: 1.2em;
            color: #7a6a62;
            font-weight: 700;
            font-family: 'Comic Neue', cursive;
        }

        /* ====== åŠ è½½åŠ¨ç”» ====== */
        .loading-spinner {
            display: inline-block;
            width: 22px;
            height: 22px;
            border: 4px solid rgba(255, 154, 139, 0.3);
            border-radius: 50%;
            border-top-color: #ff6b6b;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* ====== æˆå°±ç³»ç»Ÿæ‰‹ç»˜æ ·å¼ ====== */
        .achievement-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 25px;
            margin-top: 30px;
        }
        .achievement-card {
            background: #fffefc;
            border-radius: 20px 8px 20px 8px;
            padding: 25px;
            box-shadow: 5px 5px 0px #d4b8a7;
            border: 2.5px solid #5a4a42;
            position: relative;
            overflow: hidden;
        }
        .achievement-card.locked { 
            opacity: 0.7; 
            filter: grayscale(0.3);
            background: #f5f1eb;
        }
        .achievement-card::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 40px;
            height: 40px;
            background: rgba(255, 154, 139, 0.1);
            border-radius: 0 0 0 40px;
        }
        .achievement-icon {
            font-size: 3em;
            margin-bottom: 20px;
            text-align: center;
            transform: rotate(-3deg);
        }
        .achievement-progress {
            height: 12px;
            background: #ffe8d6;
            border-radius: 8px;
            margin: 20px 0;
            overflow: hidden;
            border: 1.5px solid #e0c9b8;
        }
        .achievement-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff9a8b, #ff6b6b);
            border-radius: 6px;
            transition: width 0.8s ease;
        }

        /* ====== æ–°å¢ï¼šæŠ˜å é¢æ¿æ ·å¼ ====== */
        .collapse-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 0.9em;
            color: #ff6b6b;
            padding: 5px 15px;
            border-radius: 20px;
            border: 2px solid #ff9a8b;
            background: #fffaf5;
            transition: all 0.3s;
            font-family: 'Comic Neue', cursive;
            font-weight: bold;
        }
        .collapse-btn:hover {
            background: #ff9a8b;
            color: white;
            transform: scale(1.05);
        }

        /* ====== æ–°å¢ï¼šç¬”è®°ç­›é€‰å™¨æ ·å¼ ====== */
        .note-filters {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
            flex-wrap: wrap;
            align-items: center;
            padding: 20px;
            background: #fffaf5;
            border-radius: 15px;
            border: 2px solid #e0c9b8;
        }
        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 200px;
        }
        .filter-group label {
            font-weight: bold;
            color: #5a4a42;
            font-family: 'Comic Neue', cursive;
        }
        .filter-group select, .filter-group input {
            padding: 12px 15px;
            border: 2px solid #e0c9b8;
            border-radius: 10px;
            font-family: 'Comic Neue', cursive;
            background: #fffefc;
            color: #5a4a42;
        }
        .filter-group select:focus, .filter-group input:focus {
            outline: none;
            border-color: #ff9a8b;
            box-shadow: 2px 2px 0px #ffd6cc;
        }

        /* ====== æ–°å¢ï¼šæ‰¹é‡æ·»åŠ æˆå°±é¢æ¿æ ·å¼ ====== */
        .batch-add-panel {
            background: #fff9f0;
            border: 3px dashed #ffc8a3;
            border-radius: 20px;
            padding: 25px;
            margin-top: 25px;
        }
        .batch-textarea {
            width: 100%;
            min-height: 200px;
            padding: 15px;
            border: 2px solid #e0c9b8;
            border-radius: 15px;
            font-family: 'Comic Neue', cursive;
            font-size: 14px;
            background: #fffefc;
            color: #5a4a42;
            margin-bottom: 15px;
            resize: vertical;
        }
        .batch-textarea:focus {
            outline: none;
            border-color: #ff9a8b;
            box-shadow: 3px 3px 0px #ffd6cc;
        }
        .batch-example {
            font-size: 0.9em;
            color: #7a6a62;
            background: #fffaf5;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            border-left: 4px solid #4ecdc4;
        }

        /* ====== æ–°å¢ï¼šå¯Œæ–‡æœ¬ç¼–è¾‘å™¨æ ·å¼ ====== */
        .rich-text-toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
            padding: 15px;
            background: #fffaf5;
            border-radius: 15px;
            border: 2px solid #e0c9b8;
            align-items: center;
        }
        .toolbar-btn {
            padding: 8px 16px;
            background: #fffefc;
            border: 2px solid #e0c9b8;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            color: #5a4a42;
            transition: all 0.2s;
            font-family: 'Comic Neue', cursive;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .toolbar-btn:hover {
            background: #ffd6cc;
            border-color: #ff9a8b;
            transform: translateY(-2px);
        }
        .toolbar-btn.active {
            background: #ff9a8b;
            color: white;
            border-color: #ff6b6b;
        }
        .color-picker {
            width: 30px;
            height: 30px;
            padding: 0;
            border: 2px solid #e0c9b8;
            border-radius: 6px;
            cursor: pointer;
        }
        .font-size-select {
            padding: 6px 10px;
            border: 2px solid #e0c9b8;
            border-radius: 8px;
            background: #fffefc;
            font-family: 'Comic Neue', cursive;
            color: #5a4a42;
        }
        .rich-text-editor {
            min-height: 300px;
            padding: 20px;
            border: 2.5px solid #e0c9b8;
            border-radius: 15px 5px 15px 5px;
            background: #fffaf9;
            font-family: 'Comic Neue', cursive;
            font-size: 16px;
            line-height: 1.6;
            color: #5a4a42;
            outline: none;
            overflow-y: auto;
            margin-bottom: 25px;
        }
        .rich-text-editor:focus {
            border-color: #ff9a8b;
            box-shadow: 3px 3px 0px #ffd6cc;
        }
        .rich-text-editor b, .rich-text-editor strong {
            color: #ff6b6b;
            font-weight: 800;
        }
        .rich-text-editor i, .rich-text-editor em {
            color: #4ecdc4;
            font-style: italic;
        }
        .rich-text-editor u {
            text-decoration: underline;
            text-decoration-color: #ff9a8b;
        }
        .rich-text-editor .highlight {
            background: linear-gradient(120deg, #ffd6cc 0%, #ffd6cc 100%);
            padding: 0 4px;
            border-radius: 4px;
        }
        .rich-text-editor h1, .rich-text-editor h2, .rich-text-editor h3 {
            font-family: 'Gochi Hand', cursive;
            margin: 20px 0 10px 0;
            color: #5a4a42;
        }
        .rich-text-editor h1 { font-size: 1.8em; }
        .rich-text-editor h2 { font-size: 1.5em; }
        .rich-text-editor h3 { font-size: 1.3em; }
        .rich-text-editor ul, .rich-text-editor ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }
        .rich-text-editor li {
            margin-bottom: 8px;
        }
        .rich-text-editor blockquote {
            border-left: 4px solid #ff9a8b;
            padding-left: 20px;
            margin: 20px 0;
            font-style: italic;
            color: #7a6a62;
            background: rgba(255, 214, 204, 0.1);
            padding: 15px;
            border-radius: 0 10px 10px 0;
        }

        /* ====== æ–°å¢ï¼šé«˜äº®å†…å®¹æå–é¢æ¿æ ·å¼ ====== */
        .highlight-extract-panel {
            background: linear-gradient(135deg, #fff9f0 0%, #fffaf5 100%);
            border: 3px solid #ffd6cc;
            border-radius: 20px;
            padding: 25px;
            margin: 25px 0;
        }
        .highlight-item {
            padding: 15px;
            margin: 10px 0;
            background: white;
            border-radius: 12px;
            border-left: 6px solid #ff9a8b;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 2px 2px 0px rgba(0,0,0,0.05);
        }
        .highlight-content {
            flex-grow: 1;
            padding: 10px;
            background: rgba(255, 214, 204, 0.2);
            border-radius: 8px;
            margin-right: 15px;
            font-weight: bold;
        }
        .highlight-actions {
            display: flex;
            gap: 10px;
        }
        .highlight-source {
            font-size: 0.9em;
            color: #7a6a62;
            margin-top: 5px;
            font-style: italic;
        }

        /* ====== æ–°å¢ï¼šWordå¼æ–‡æ¡£é¢„è§ˆ ====== */
        .word-document {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 0 30px rgba(0,0,0,0.1);
            border: 1px solid #e0c9b8;
            min-height: 800px;
            margin: 30px 0;
            position: relative;
            overflow: hidden;
        }
        .word-document::before {
            content: '';
            position: absolute;
            top: 0;
            left: 40px;
            right: 40px;
            height: 1px;
            background: repeating-linear-gradient(
                90deg,
                transparent,
                transparent 2px,
                #e0c9b8 2px,
                #e0c9b8 4px
            );
        }
        .word-header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 3px double #e0c9b8;
        }
        .word-content {
            font-size: 16px;
            line-height: 1.8;
            font-family: 'Comic Neue', cursive;
        }
        .word-page-number {
            position: absolute;
            bottom: 20px;
            right: 40px;
            color: #7a6a62;
            font-size: 0.9em;
        }

        /* ====== æ–°å¢ï¼šä»£ç å—æ ·å¼ ====== */
        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            overflow-x: auto;
            border-left: 4px solid #ff9a8b;
        }
        .code-block pre {
            margin: 0;
        }
        .code-block .keyword { color: #ff6b6b; }
        .code-block .string { color: #a3de83; }
        .code-block .comment { color: #7a6a62; font-style: italic; }
        .code-block .function { color: #4ecdc4; }
        .code-block .number { color: #ffd166; }
        
        /* ====== æ€ç»´å¯¼å›¾æ ·å¼ ====== */
        .mindmap-container {
            position: relative;
            width: 100%;
            height: 500px;
            background: #fffaf5;
            border: 2.5px solid #e0c9b8;
            border-radius: 15px 5px 15px 5px;
            margin: 20px 0;
            overflow: hidden;
        }
        .mindmap-node {
            position: absolute;
            width: 120px;
            height: 30px;
            padding: 10px 15px;
            background: #fffefc;
            border-radius: 10px 5px 10px 5px;
            border: 2px solid #5a4a42;
            box-shadow: 3px 3px 0px #d4b8a7;
            font-family: 'Comic Neue', cursive;
            font-weight: bold;
            color: #5a4a42;
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            user-select: none;
            transition: all 0.2s;
        }
        .mindmap-node:hover {
            box-shadow: 4px 4px 0px #c9a58f;
            transform: translateY(-2px);
        }
        .mindmap-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .mindmap-input {
            flex-grow: 1;
            padding: 12px 15px;
            border: 2px solid #e0c9b8;
            border-radius: 10px;
            font-family: 'Comic Neue', cursive;
            background: #fffefc;
            color: #5a4a42;
        }
        .mindmap-input:focus {
            outline: none;
            border-color: #ff9a8b;
            box-shadow: 2px 2px 0px #ffd6cc;
        }
        .mindmap-nodes-list {
            margin: 20px 0;
            padding: 15px;
            background: #fffaf5;
            border-radius: 15px;
            border: 2px solid #e0c9b8;
        }
        .mindmap-node-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 8px 0;
            background: white;
            border-radius: 8px;
            border-left: 4px solid #ff9a8b;
        }

        /* ====== æ–°å¢ï¼šè¯»ä¹¦ç¬”è®°æ ·å¼ ====== */
        .reading-notes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 30px;
            margin-top: 30px;
        }
        .reading-note-card {
            background: #fffefc;
            border-radius: 20px 8px 20px 8px;
            padding: 25px;
            box-shadow: 6px 6px 0px #d4b8a7;
            border: 2.5px solid #5a4a42;
            position: relative;
            transition: all 0.3s;
        }
        .reading-note-card:hover {
            transform: translateY(-5px) rotate(0.5deg);
            box-shadow: 8px 8px 0px #c9a58f, 15px 15px 25px rgba(0, 0, 0, 0.09);
        }
        .reading-note-card::before {
            content: 'ğŸ“–';
            position: absolute;
            top: -15px;
            right: 20px;
            font-size: 1.5em;
            transform: rotate(15deg);
        }
        .reading-note-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
        }
        .reading-note-title {
            font-family: 'Gochi Hand', cursive;
            font-size: 1.8em;
            color: #5a4a42;
            margin-bottom: 5px;
            line-height: 1.2;
        }
        .reading-note-author {
            font-size: 1em;
            color: #7a6a62;
            font-weight: bold;
        }
        .rating-stars {
            display: flex;
            gap: 5px;
            margin: 15px 0;
        }
        .star {
            font-size: 1.8em;
            cursor: pointer;
            transition: all 0.2s;
            color: #e0c9b8;
        }
        .star.filled {
            color: #ffd166;
            text-shadow: 0 0 5px rgba(255, 209, 102, 0.5);
        }
        .star:hover {
            transform: scale(1.2);
        }
        .reading-note-section {
            margin: 20px 0;
            padding: 20px;
            background: #fffaf5;
            border-radius: 15px 5px 15px 5px;
            border: 2px solid #e0c9b8;
        }
        .reading-note-section h4 {
            font-family: 'Gochi Hand', cursive;
            color: #5a4a42;
            margin-bottom: 15px;
            font-size: 1.3em;
            border-bottom: 2px dotted #ff9a8b;
            padding-bottom: 8px;
        }
        .reading-note-content {
            color: #5a4a42;
            line-height: 1.6;
            white-space: pre-line;
        }
        .reading-note-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 25px;
            padding-top: 20px;
            border-top: 2px dashed #ffc8a3;
            font-size: 0.9em;
            color: #7a6a62;
        }
        .reading-note-actions {
            display: flex;
            gap: 10px;
        }
        .reading-editor {
            background: #fffefc;
            border-radius: 20px 10px 20px 10px;
            padding: 30px;
            box-shadow: 6px 6px 0px #d4b8a7;
            border: 2.5px solid #5a4a42;
            margin-bottom: 30px;
        }
        .reading-editor-section {
            margin-bottom: 25px;
        }
        .reading-editor-section label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #5a4a42;
            font-family: 'Comic Neue', cursive;
            font-size: 1.1em;
        }
        .reading-textarea {
            width: 100%;
            min-height: 120px;
            padding: 15px;
            border: 2.5px solid #e0c9b8;
            border-radius: 15px 5px 15px 5px;
            font-size: 16px;
            font-family: 'Comic Neue', cursive;
            margin-bottom: 25px;
            transition: all 0.3s;
            background: #fffaf9;
            resize: vertical;
        }
        .reading-textarea:focus {
            outline: none;
            border-color: #ff9a8b;
            box-shadow: 3px 3px 0px #ffd6cc;
            background: #fff;
        }
        .rating-display {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 15px 0;
        }
        .rating-value {
            font-family: 'Gochi Hand', cursive;
            font-size: 1.5em;
            color: #ff6b6b;
            font-weight: bold;
        }
        .reading-filter {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
            padding: 20px;
            background: #fffaf5;
            border-radius: 15px;
            border: 2px solid #e0c9b8;
            flex-wrap: wrap;
            align-items: center;
        }
        .reading-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 20px;
            margin: 30px 0;
            text-align: center;
        }
        .reading-stat {
            padding: 20px;
            background: #fffaf5;
            border-radius: 15px;
            border: 2px solid #e0c9b8;
        }
        .reading-stat-value {
            font-size: 2.5em;
            font-weight: 800;
            font-family: 'Gochi Hand', cursive;
            color: #ff6b6b;
            line-height: 1;
        }
        .reading-stat-label {
            margin-top: 10px;
            font-size: 1em;
            color: #7a6a62;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="app" class="container">
        <!-- === é…ç½®é¢æ¿ === -->
        <div v-if="!isConfigured" class="config-panel">
            <div class="card">
                <h2>âœï¸ è®¾ç½®ä½ çš„æ‰‹è´¦åŒæ­¥</h2>
                <div class="config-info">
                    <p><strong>å‡†å¤‡äº‹é¡¹ï¼š</strong></p>
                    <ol style="margin-left: 20px; margin-top: 10px;">
                        <li>ä¸€ä¸ªGitHubè´¦å·</li>
                        <li>ä¸€ä¸ª<strong>ç§æœ‰ä»“åº“</strong>å­˜æ”¾æ•°æ®</li>
                        <li>ä¸€ä¸ªæœ‰ <code>repo</code> æƒé™çš„<strong>è®¿é—®ä»¤ç‰Œ</strong>
                            <br><a href="https://github.com/settings/tokens" target="_blank">ç‚¹æ­¤åˆ›å»ºToken</a>
                        </li>
                    </ol>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">GitHub ç”¨æˆ·å</label>
                    <input type="text" v-model="config.username" class="note-input" placeholder="ä¾‹å¦‚ï¼šzhangsan">
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">æ•°æ®ä»“åº“åç§°</label>
                    <input type="text" v-model="config.repo" class="note-input" placeholder="ä¾‹å¦‚ï¼šmy-growth-data">
                </div>
                
                <div style="margin-bottom: 30px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">ä¸ªäººè®¿é—®ä»¤ç‰Œ (Token)</label>
                    <input type="password" v-model="config.token" class="note-input" placeholder="ghp_xxxxxxxxxxxxxxxxxxxx">
                    <p style="font-size: 0.9em; color: #7a6a62; margin-top: 5px;">
                        âš ï¸ Tokenä»…ç”¨äºæœ¬æ¬¡ä¼šè¯é€šä¿¡ï¼Œåˆ·æ–°é¡µé¢åéœ€é‡æ–°è¾“å…¥ã€‚
                    </p>
                </div>
                
                <div style="display: flex; gap: 15px;">
                    <button class="btn" @click="saveConfigAndLoad" style="flex: 1;">
                        <span v-if="isLoading">âŒ› è¿æ¥ä¸­...</span>
                        <span v-else>âœ… è¿æ¥å¹¶åŠ è½½æ•°æ®</span>
                    </button>
                    <button class="btn" @click="loadDemoData" style="flex: 1; background:linear-gradient(90deg, #a3a3a3, #7a7a7a);" :disabled="isLoading">
                        ğŸ® è¯•ç”¨æ‰‹è´¦æ•°æ®
                    </button>
                </div>
                
                <div v-if="configError" class="status-error status-message">
                    {{ configError }}
                </div>
            </div>
        </div>

        <!-- === ä¸»æ‰‹è´¦ç•Œé¢ === -->
        <div v-else>
            <!-- é¡¶éƒ¨çŠ¶æ€æ  -->
            <div class="header">
                <h1>âœï¸ æ™ºèƒ½æˆé•¿æ‰‹è´¦</h1>
                <p>æ•°æ®åŒæ­¥è‡³: <strong>{{ config.username }}/{{ config.repo }}</strong></p>
                
                <div style="position: absolute; top: 30px; right: 30px; display: flex; gap: 10px;">
                    <button class="btn-sm" @click="forceLoadFromGitHub" :disabled="isLoading">
                        <span v-if="isLoading">âŒ› åŒæ­¥ä¸­...</span>
                        <span v-else>ğŸ”„ ç«‹å³åŒæ­¥</span>
                    </button>
                    <button class="btn-sm" @click="forceSaveToGitHub" :disabled="isSaving" style="background:linear-gradient(90deg, #4ecdc4, #2ba69b);">
                        <span v-if="isSaving">ğŸ’¾ ä¿å­˜ä¸­...</span>
                        <span v-else>ğŸ’¾ ç«‹å³ä¿å­˜</span>
                    </button>
                    <button class="btn-sm" @click="showConfig=!showConfig" style="background:linear-gradient(90deg, #7a6a62, #5a4a42);">
                        âš™ï¸ {{ showConfig ? 'éšè—è®¾ç½®' : 'æ˜¾ç¤ºè®¾ç½®' }}
                    </button>
                </div>
                
                <div style="font-size: 0.95em; opacity: 0.9; margin-top: 15px; display: flex; align-items: center; justify-content: center; gap: 20px;">
                    <span>ğŸ•’ æœ€ååŒæ­¥: {{ lastSyncTime || 'ä»æœªåŒæ­¥' }}</span>
                    <span v-if="isSaving" style="color: #ff6b6b;">
                        <span class="loading-spinner" style="margin-right: 5px;"></span> æ­£åœ¨ä¿å­˜...
                    </span>
                </div>
            </div>

            <!-- é…ç½®æŠ½å±‰ -->
            <div v-if="showConfig" class="card" style="margin-bottom: 30px;">
                <h3>âš™ï¸ åŒæ­¥è®¾ç½®</h3>
                <p>å½“å‰ä»“åº“: <code>{{ config.username }}/{{ config.repo }}</code></p>
                <p style="font-size: 0.95em; color: #7a6a62; margin-top: 10px;">
                    Token: {{ config.token ? 'å·²è®¾ç½® (' + config.token.substring(0, 8) + '...)' : 'æœªè®¾ç½®' }}
                </p>
                <div style="display: flex; gap: 10px; margin-top: 25px; flex-wrap: wrap;">
                    <button class="btn-sm" @click="openRepoInGitHub" style="background:linear-gradient(90deg, #4a9fff, #2d73cc);">ğŸ“‚ æ‰“å¼€ä»“åº“</button>
                    <button class="btn-sm" @click="exportLocalData" style="background:linear-gradient(90deg, #a3de83, #4ecdc4);">ğŸ’¾ å¤‡ä»½æ•°æ®</button>
                    <button class="btn-sm" @click="showImport=!showImport" style="background:linear-gradient(90deg, #ffd166, #ffb347); color:#5a4a42;">ğŸ“‚ å¯¼å…¥æ•°æ®</button>
                    <button class="btn-sm" @click="isConfigured=false" style="background:#f0e6dc; color:#5a4a42; border:2px solid #d4b8a7;">âœï¸ ä¿®æ”¹è®¾ç½®</button>
                </div>
                
                <!-- å¯¼å…¥æ•°æ®åŒºåŸŸ -->
                <div v-if="showImport" style="margin-top: 25px; padding-top: 25px; border-top: 3px dashed #e0c9b8;">
                    <h4>å¯¼å…¥å¤‡ä»½æ•°æ®</h4>
                    <input type="file" accept=".json" @change="importLocalData" style="margin: 15px 0; padding: 10px; border: 2px dashed #ffc8a3; border-radius: 10px; width:100%; background:#fffaf9;">
                    <p style="font-size: 0.95em; color: #7a6a62;">é€‰æ‹©ä¹‹å‰å¯¼å‡ºçš„JSONå¤‡ä»½æ–‡ä»¶</p>
                </div>
            </div>
            
            <!-- çŠ¶æ€æ¶ˆæ¯ -->
            <div v-if="statusMessage" :class="['status-message', statusMessage.type === 'success' ? 'status-success' : statusMessage.type === 'error' ? 'status-error' : 'status-warning']">
                {{ statusMessage.text }}
            </div>

            <!-- ä¸»ç½‘æ ¼å¸ƒå±€ -->
            <div class="grid">
                <!-- ç©å®¶çŠ¶æ€é¢æ¿ -->
                <div class="card">
                    <h2>
                        ğŸ“Š æˆé•¿çŠ¶æ€
                        <button class="collapse-btn" @click="collapseStatus = !collapseStatus">
                            {{ collapseStatus ? 'å±•å¼€' : 'æŠ˜å ' }}
                        </button>
                    </h2>
                    <div v-if="!collapseStatus">
                        <div class="level-display">Lv. {{ player.level }}</div>
                        <div style="margin: 25px 0;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 12px; font-weight:bold;">
                                <span>ç»éªŒå€¼ (XP):</span>
                                <span><strong>{{ player.xp }}</strong> / {{ player.nextLevelXp }}</span>
                            </div>
                            <div class="xp-progress">
                                <div class="xp-fill" :style="{ width: (player.xp / player.nextLevelXp * 100) + '%' }"></div>
                            </div>
                            <div style="text-align: center; margin-top: 18px; font-size: 1.05em; color: #7a6a62; font-weight:bold;">
                                è¿˜éœ€ {{ player.nextLevelXp - player.xp }} XP å‡çº§
                            </div>
                        </div>
                        
                        <div style="margin-top: 30px; padding-top: 30px; border-top: 3px dotted #ffc8a3;">
                            <div class="stats-grid" style="grid-template-columns: 1fr 1fr; gap: 20px;">
                                <div>
                                    <div style="font-size: 2.2em; font-weight: bold; color: #ff6b6b; font-family:'Gochi Hand';">{{ totalSkills }}</div>
                                    <div style="color: #7a6a62; font-weight:bold;">æŠ€èƒ½æ•°é‡</div>
                                </div>
                                <div>
                                    <div style="font-size: 2.2em; font-weight: bold; color: #4ecdc4; font-family:'Gochi Hand';">{{ completedAchievementsCount }}</div>
                                    <div style="color: #7a6a62; font-weight:bold;">æˆå°±è¾¾æˆ</div>
                                </div>
                            </div>
                            <button class="btn" @click="forceSaveToGitHub" style="background:linear-gradient(90deg, #4ecdc4, #2ba69b); margin-top:20px;">
                                ğŸ’¾ ç«‹å³ä¿å­˜åˆ°äº‘ç«¯
                            </button>
                            <button class="btn" @click="resetData" style="background:linear-gradient(90deg, #ff7b6b, #d45d5d); margin-top:15px;">
                                ğŸ”„ é‡ç½®æ‰€æœ‰æ•°æ®ï¼ˆè°¨æ…ï¼ï¼‰
                            </button>
                        </div>
                    </div>
                </div>

                <!-- æŠ€èƒ½æ ‘ -->
                <div class="card">
                    <h2>
                        ğŸŒ± æˆ‘çš„æŠ€èƒ½æ ‘
                        <button class="collapse-btn" @click="collapseSkills = !collapseSkills">
                            {{ collapseSkills ? 'å±•å¼€' : 'æŠ˜å ' }}
                        </button>
                    </h2>
                    <div v-if="!collapseSkills">
                        <p style="margin-bottom:20px; color:#7a6a62; font-weight:bold;">ä»é›¶å¼€å§‹ï¼Œè‡ªç”±æ·»åŠ ä½ æƒ³åŸ¹å…»çš„ä»»ä½•æŠ€èƒ½</p>
                        
                        <div v-if="skills.length === 0" style="text-align:center; padding:40px 20px; color:#c9b8a7;">
                            <div style="font-size:3.5em; margin-bottom:15px; transform:rotate(-5deg);">ğŸŒ±</div>
                            <p style="font-weight:bold; font-size:1.1em;">æŠ€èƒ½æ ‘ç©ºç©ºå¦‚ä¹Ÿ</p>
                            <p>ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®æ·»åŠ ä½ çš„ç¬¬ä¸€ä¸ªæŠ€èƒ½å§ï¼</p>
                        </div>
                        
                        <div v-for="skill in skills" :key="skill.id" class="skill-item">
                            <div style="flex-grow:1;">
                                <div style="display:flex; align-items:center; gap:15px; margin-bottom:10px;">
                                    <span style="font-size:2em; transform:rotate(3deg);">{{ skill.icon }}</span>
                                    <div>
                                        <strong style="font-size:1.3em; color:#5a4a42;">{{ skill.name }}</strong>
                                        <div style="font-size:0.95em; color:#7a6a62; font-weight:bold;">ç±»åˆ«: {{ skill.category }} Â· ç­‰çº§ {{ skill.level }}</div>
                                    </div>
                                </div>
                                <div class="xp-progress" style="height:14px; margin:12px 0;">
                                    <div class="xp-fill" :style="{ width: (skill.xp / skill.maxXp * 100) + '%' }"></div>
                                </div>
                                <div style="display:flex; justify-content:space-between; font-size:0.95em; color:#7a6a62; font-weight:bold;">
                                    <span>{{ skill.xp }} / {{ skill.maxXp }} XP</span>
                                    <span>{{ Math.round(skill.xp / skill.maxXp * 100) }}%</span>
                                </div>
                            </div>
                            <div style="display:flex; gap:12px;">
                                <button class="btn-sm" @click="practiceSkill(skill.id)" style="background:linear-gradient(90deg, #ff9a8b, #ff6b6b); box-shadow:3px 3px 0px #d45d5d;">
                                    ç»ƒä¹  +{{ getSkillXpPerPractice(skill) }}
                                </button>
                                <button class="btn-sm" @click="deleteSkill(skill.id)" style="background:#f0e6dc; color:#7a6a62; border:2px solid #d4b8a7; box-shadow:3px 3px 0px #c9b8a7;">
                                    åˆ é™¤
                                </button>
                            </div>
                        </div>
                        
                        <button class="btn" @click="addNewSkill" style="background:linear-gradient(90deg, #a3de83, #4ecdc4); margin-top:25px;">
                            ğŸŒŸ æ·»åŠ æ–°æŠ€èƒ½
                        </button>
                    </div>
                </div>

                <!-- æˆå°±ç³»ç»Ÿ -->
                <div class="card">
                    <h2>
                        ğŸ† æˆå°±ç³»ç»Ÿ
                        <button class="collapse-btn" @click="collapseAchievements = !collapseAchievements">
                            {{ collapseAchievements ? 'å±•å¼€' : 'æŠ˜å ' }}
                        </button>
                    </h2>
                    
                    <div v-if="!collapseAchievements">
                        <!-- æˆå°±ç­›é€‰ä¸æ‰¹é‡æ·»åŠ åŒºåŸŸ -->
                        <div style="margin-bottom: 25px; display: flex; gap: 15px; align-items: center;">
                            <div class="note-tabs" style="margin-bottom: 0; flex-grow: 1;">
                                <div class="note-tab" :class="{active: activeAchievementTab === 'all'}" @click="activeAchievementTab = 'all'">å…¨éƒ¨</div>
                                <div class="note-tab" :class="{active: activeAchievementTab === 'yixue'}" @click="activeAchievementTab = 'yixue'">æ˜“å­¦</div>
                                <div class="note-tab" :class="{active: activeAchievementTab === 'english'}" @click="activeAchievementTab = 'english'">è‹±è¯­</div>
                                <div class="note-tab" :class="{active: activeAchievementTab === 'fitness'}" @click="activeAchievementTab = 'fitness'">å¥èº«</div>
                                <div class="note-tab" :class="{active: activeAchievementTab === 'custom'}" @click="activeAchievementTab = 'custom'">è‡ªå®šä¹‰</div>
                            </div>
                            <button class="btn-sm" @click="showBatchAdd = !showBatchAdd" style="background:linear-gradient(90deg, #ffd166, #ffb347); color:#5a4a42;">
                                ğŸ“¥ æ‰¹é‡æ·»åŠ æˆå°±
                            </button>
                        </div>
                        
                        <!-- æ‰¹é‡æ·»åŠ æˆå°±é¢æ¿ -->
                        <div v-if="showBatchAdd" class="batch-add-panel">
                            <h3 style="margin-bottom: 15px; color: #5a4a42;">ğŸ“¥ æ‰¹é‡æ·»åŠ æˆå°±</h3>
                            <p style="margin-bottom: 15px; color: #7a6a62; font-weight: bold;">
                                è¯·æŒ‰ç…§JSONæ ¼å¼è¾“å…¥æˆå°±æ•°æ®ï¼Œæ¯ä¸ªæˆå°±åŒ…å«ä»¥ä¸‹å­—æ®µï¼š
                            </p>
                            <textarea 
                                v-model="batchAchievementInput" 
                                class="batch-textarea" 
                                placeholder='ä¾‹å¦‚ï¼š
[
  {
    "category": "custom",
    "name": "æ—©èµ·è¾¾äºº",
    "icon": "ğŸŒ…",
    "description": "è¿ç»­30å¤©æ—©ä¸Š6ç‚¹å‰èµ·åºŠ",
    "requirement": 30,
    "reward": 150
  }
]'>
                            </textarea>
                            <div class="batch-example">
                                <strong>å­—æ®µè¯´æ˜ï¼š</strong><br>
                                â€¢ <code>category</code>: åˆ†ç±»ï¼ˆè‡ªå®šä¹‰åˆ†ç±»ä¼šè‡ªåŠ¨åˆ›å»ºï¼‰<br>
                                â€¢ <code>name</code>: æˆå°±åç§°<br>
                                â€¢ <code>icon</code>: å›¾æ ‡è¡¨æƒ…<br>
                                â€¢ <code>description</code>: æè¿°<br>
                                â€¢ <code>requirement</code>: è¾¾æˆè¦æ±‚ï¼ˆæ•°å­—ï¼‰<br>
                                â€¢ <code>reward</code>: å¥–åŠ±ç»éªŒå€¼
                            </div>
                            <div style="display: flex; gap: 15px; margin-top: 20px;">
                                <button class="btn-sm" @click="addBatchAchievements" style="background:linear-gradient(90deg, #a3de83, #4ecdc4);">
                                    âœ… æ·»åŠ è¿™äº›æˆå°±
                                </button>
                                <button class="btn-sm" @click="loadExampleAchievements" style="background:linear-gradient(90deg, #4a9fff, #2d73cc);">
                                    ğŸ“‹ åŠ è½½ç¤ºä¾‹
                                </button>
                                <button class="btn-sm" @click="clearBatchInput" style="background:linear-gradient(90deg, #a3a3a3, #7a7a7a);">
                                    æ¸…ç©º
                                </button>
                            </div>
                        </div>
                        
                        <div class="achievement-grid">
                            <div v-for="achievement in filteredAchievements" :key="achievement.id" 
                                 class="achievement-card" :class="{locked: !achievement.unlocked}">
                                <div class="achievement-icon">{{ achievement.icon }}</div>
                                <h3 style="margin-bottom:12px; color:#5a4a42; font-family:'Gochi Hand';">{{ achievement.name }}</h3>
                                <p style="font-size:0.95em; color:#7a6a62; margin-bottom:20px; min-height:45px; font-weight:bold;">{{ achievement.description }}</p>
                                
                                <div v-if="!achievement.unlocked">
                                    <div class="achievement-progress">
                                        <div class="achievement-progress-fill" 
                                             :style="{ width: Math.min(100, (achievement.current / achievement.requirement * 100)) + '%' }"></div>
                                    </div>
                                    <div style="display:flex; justify-content:space-between; font-size:0.9em; color:#7a6a62; font-weight:bold;">
                                        <span>è¿›åº¦: {{ achievement.current }} / {{ achievement.requirement }}</span>
                                        <span>{{ Math.round(achievement.current / achievement.requirement * 100) }}%</span>
                                    </div>
                                </div>
                                
                                <div v-if="achievement.unlocked" 
                                     style="text-align:center; padding:15px; background:rgba(163,222,131,0.2); border-radius:15px; margin-top:20px; border:2px dashed #4ecdc4;">
                                    <span style="color:#2d5a27; font-weight:bold; font-family:'Gochi Hand';">ğŸ‰ å·²è§£é”</span>
                                    <div style="font-size:0.95em; color:#2d5a27; margin-top:8px; font-weight:bold;">
                                        {{ achievement.reward }} XP
                                    </div>
                                </div>
                                
                                <!-- åˆ é™¤æˆå°±æŒ‰é’®ï¼ˆä»…è‡ªå®šä¹‰æˆå°±æ˜¾ç¤ºï¼‰ -->
                                <div v-if="achievement.category === 'custom'" style="margin-top: 15px; text-align: right;">
                                    <button class="btn-sm" @click="deleteAchievement(achievement.id)" style="background:linear-gradient(90deg, #ff7b6b, #d45d5d); padding: 5px 15px; font-size: 0.8em;">
                                        åˆ é™¤
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- ç©ºçŠ¶æ€æç¤º -->
                        <div v-if="filteredAchievements.length === 0" style="text-align:center; padding:50px 20px; color:#c9b8a7; margin-top: 30px;">
                            <div style="font-size:4em; margin-bottom:20px; transform:rotate(-5deg);">ğŸ†</div>
                            <p style="font-weight:bold; font-size:1.3em; margin-bottom:10px;">è¿™ä¸ªåˆ†ç±»è¿˜æ²¡æœ‰æˆå°±</p>
                            <p>ç‚¹å‡»"æ‰¹é‡æ·»åŠ æˆå°±"æŒ‰é’®åˆ›å»ºä½ çš„ç¬¬ä¸€ä¸ªæˆå°±å§ï¼</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- æ™ºèƒ½ç¬”è®°ç³»ç»Ÿ -->
            <div class="note-section">
                <div class="card">
                    <h2>
                        ğŸ“ æ™ºèƒ½ç¬”è®°ç³»ç»Ÿ
                        <button class="collapse-btn" @click="collapseNotes = !collapseNotes">
                            {{ collapseNotes ? 'å±•å¼€' : 'æŠ˜å ' }}
                        </button>
                    </h2>
                    
                    <div v-if="!collapseNotes">
                        <!-- ç¬”è®°ç­›é€‰å™¨ -->
                        <div class="note-filters" v-if="activeNoteTab !== 'editor' && notes.length > 0">
                            <div class="filter-group">
                                <label>ğŸ“… æ—¶é—´èŒƒå›´</label>
                                <select v-model="noteFilter.timeRange">
                                    <option value="all">å…¨éƒ¨æ—¶é—´</option>
                                    <option value="today">ä»Šå¤©</option>
                                    <option value="week">æœ¬å‘¨</option>
                                    <option value="month">æœ¬æœˆ</option>
                                    <option value="year">ä»Šå¹´</option>
                                </select>
                            </div>
                            
                            <div class="filter-group">
                                <label>ğŸ·ï¸ æ ‡ç­¾ç­›é€‰</label>
                                <select v-model="noteFilter.selectedTag">
                                    <option value="">æ‰€æœ‰æ ‡ç­¾</option>
                                    <option v-for="tag in allNoteTags" :value="tag">{{ tag }}</option>
                                </select>
                            </div>
                            
                            <div class="filter-group">
                                <label>ğŸ“ åˆ†ç±»ç­›é€‰</label>
                                <select v-model="noteFilter.selectedCategory">
                                    <option value="">æ‰€æœ‰åˆ†ç±»</option>
                                    <option v-for="cat in noteCategories.filter(c => c !== 'all' && c !== 'editor')" :value="cat">
                                        {{ getCategoryDisplayName(cat) }}
                                    </option>
                                </select>
                            </div>
                            
                            <div class="filter-group">
                                <label>ğŸ” å…³é”®è¯æœç´¢</label>
                                <input type="text" v-model="noteFilter.keyword" placeholder="æœç´¢æ ‡é¢˜æˆ–å†…å®¹...">
                            </div>
                            
                            <div class="filter-group">
                                <label>âœ¨ æ ¼å¼ç­›é€‰</label>
                                <select v-model="noteFilter.formatType">
                                    <option value="">æ‰€æœ‰æ ¼å¼</option>
                                    <option value="highlight">åŒ…å«é«˜äº®</option>
                                    <option value="bold">åŒ…å«åŠ ç²—</option>
                                    <option value="code">åŒ…å«ä»£ç </option>
                                    <option value="image">åŒ…å«å›¾ç‰‡</option>
                                </select>
                            </div>
                            
                            <button class="btn-sm" @click="resetNoteFilters" style="align-self: flex-end; background:linear-gradient(90deg, #a3a3a3, #7a7a7a);">
                                é‡ç½®ç­›é€‰
                            </button>
                        </div>
                        
                        <!-- ç¬”è®°åˆ†ç±»æ ‡ç­¾é¡µ -->
                        <div class="note-tabs">
                            <div class="note-tab" :class="{active: activeNoteTab === 'all'}" @click="activeNoteTab = 'all'">ğŸ“š å…¨éƒ¨ç¬”è®°</div>
                            <div class="note-tab" :class="{active: activeNoteTab === 'editor'}" @click="activeNoteTab = 'editor'">âœï¸ å¯Œæ–‡æœ¬ç¼–è¾‘</div>
                            <div class="note-tab" :class="{active: activeNoteTab === 'reading'}" @click="activeNoteTab = 'reading'">ğŸ“– è¯»ä¹¦ç¬”è®°</div>
                            <div class="note-tab" :class="{active: activeNoteTab === 'mindmap'}" @click="activeNoteTab = 'mindmap'">ğŸ§  æ€ç»´å¯¼å›¾</div>
                            <div class="note-tab" :class="{active: activeNoteTab === 'highlights'}" @click="activeNoteTab = 'highlights'">ğŸŒŸ é«˜äº®æå–</div>
                            <div class="note-tab" :class="{active: activeNoteTab === 'wordview'}" @click="activeNoteTab = 'wordview'">ğŸ“„ Wordé¢„è§ˆ</div>
                            <div v-for="cat in noteCategories.filter(c => c !== 'all' && c !== 'editor' && c !== 'reading' && c !== 'mindmap' && c !== 'highlights' && c !== 'wordview')" :key="cat" 
                                 class="note-tab" 
                                 :class="{active: activeNoteTab === cat}" 
                                 @click="activeNoteTab = cat">
                                {{ getCategoryDisplayName(cat) }}
                            </div>
                        </div>
                        
                        <!-- å¯Œæ–‡æœ¬ç¼–è¾‘å™¨ -->
                        <div v-if="activeNoteTab === 'editor'" class="note-editor">
                            <input type="text" class="note-input" v-model="newNote.title" placeholder="ç¬”è®°æ ‡é¢˜...">
                            
                            <!-- å¯Œæ–‡æœ¬å·¥å…·æ  -->
                            <div class="rich-text-toolbar">
                                <button class="toolbar-btn" @click="formatText('bold')" :class="{active: activeFormat === 'bold'}">
                                    <strong>B</strong> åŠ ç²—
                                </button>
                                <button class="toolbar-btn" @click="formatText('italic')" :class="{active: activeFormat === 'italic'}">
                                    <em>I</em> æ–œä½“
                                </button>
                                <button class="toolbar-btn" @click="formatText('underline')" :class="{active: activeFormat === 'underline'}">
                                    <u>U</u> ä¸‹åˆ’çº¿
                                </button>
                                <button class="toolbar-btn" @click="formatText('highlight')" :class="{active: activeFormat === 'highlight'}">
                                    <span style="background:#ffd6cc; padding:2px 5px;">ğŸ“</span> é«˜äº®
                                </button>
                                
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <label style="font-weight: bold; color: #5a4a42;">æ ‡é¢˜:</label>
                                    <button class="toolbar-btn" @click="formatText('h1')">H1</button>
                                    <button class="toolbar-btn" @click="formatText('h2')">H2</button>
                                    <button class="toolbar-btn" @click="formatText('h3')">H3</button>
                                </div>
                                
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <label style="font-weight: bold; color: #5a4a42;">åˆ—è¡¨:</label>
                                    <button class="toolbar-btn" @click="formatText('ul')">â€¢ æ— åº</button>
                                    <button class="toolbar-btn" @click="formatText('ol')">1. æœ‰åº</button>
                                </div>
                                
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <label style="font-weight: bold; color: #5a4a42;">å¼•ç”¨:</label>
                                    <button class="toolbar-btn" @click="formatText('blockquote')">" å¼•ç”¨</button>
                                </div>
                                
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <label style="font-weight: bold; color: #5a4a42;">é¢œè‰²:</label>
                                    <input type="color" v-model="textColor" class="color-picker" @change="changeTextColor">
                                </div>
                                
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <label style="font-weight: bold; color: #5a4a42;">å­—å·:</label>
                                    <select v-model="fontSize" class="font-size-select" @change="changeFontSize">
                                        <option value="14">å°</option>
                                        <option value="16">æ­£å¸¸</option>
                                        <option value="18">ä¸­</option>
                                        <option value="20">å¤§</option>
                                        <option value="24">ç‰¹å¤§</option>
                                    </select>
                                </div>
                                
                                <button class="toolbar-btn" @click="insertCodeBlock">
                                    &lt;/&gt; ä»£ç 
                                </button>
                                <button class="toolbar-btn" @click="clearFormatting">
                                    ğŸ—‘ï¸ æ¸…é™¤æ ¼å¼
                                </button>
                            </div>
                            
                            <!-- å¯Œæ–‡æœ¬ç¼–è¾‘åŒºåŸŸ -->
                            <div 
                                ref="richTextEditor"
                                class="rich-text-editor" 
                                contenteditable="true"
                                @input="updateRichTextContent"
                                @focus="editorFocused = true"
                                @blur="editorFocused = false"
                                :style="{ fontSize: fontSize + 'px' }"
                            >
                                {{ newNote.content }}
                            </div>
                            
                            <input type="text" class="tag-input" v-model="newNote.tagsInput" placeholder="æ·»åŠ æ ‡ç­¾ï¼Œç”¨é€—å·åˆ†éš” (ä¾‹å¦‚: å­¦ä¹ , å¤ç›˜, çµæ„Ÿ)">
                            
                            <!-- å›¾ç‰‡ä¸Šä¼ åŒºåŸŸ -->
                            <div class="image-upload-area">
                                <label style="display: block; margin-bottom: 12px; font-weight: bold; font-size:1.1em;">ğŸ“¸ æ·»åŠ å›¾ç‰‡</label>
                                <input type="file" accept="image/*" @change="handleImageUpload" style="display: block; margin: 0 auto 15px; padding:10px; border:2px dashed #ff9a8b; border-radius:10px; background:#fffaf9; cursor:pointer;">
                                <p style="font-size: 0.95em; color: #7a6a62; margin-bottom: 10px; font-weight:bold;">æ”¯æŒ JPG, PNG, GIF æ ¼å¼ï¼Œæœ€å¤§ 2MB</p>
                                
                                <div v-if="newNote.imageData" class="image-preview">
                                    <p style="font-weight:bold; margin-bottom:10px;">å›¾ç‰‡é¢„è§ˆï¼š</p>
                                    <img :src="newNote.imageData" alt="é¢„è§ˆ">
                                    <button class="btn-sm" @click="clearUploadedImage" style="background: #ffd6cc; color: #5a4a42; margin-top: 15px; border:2px solid #ff9a8b;">
                                        æ¸…é™¤å›¾ç‰‡
                                    </button>
                                </div>
                            </div>
                            
                            <div style="display:flex; gap:15px; margin-top:25px;">
                                <button class="btn" @click="saveRichTextNote" style="width:auto; padding:14px 45px; border-radius:50px 15px 50px 15px;">
                                    ğŸ’¾ ä¿å­˜å¯Œæ–‡æœ¬ç¬”è®°
                                </button>
                                <button class="btn" @click="clearNoteEditor" 
                                        style="width:auto; padding:14px 35px; background:linear-gradient(90deg, #a3a3a3, #7a7a7a); border-radius:50px 15px 50px 15px;">
                                    æ¸…ç©ºé‡å†™
                                </button>
                                <button class="btn" @click="previewNote" 
                                        style="width:auto; padding:14px 35px; background:linear-gradient(90deg, #4a9fff, #2d73cc); border-radius:50px 15px 50px 15px;">
                                    ğŸ‘ï¸ é¢„è§ˆæ•ˆæœ
                                </button>
                            </div>
                        </div>
                        
                        <!-- è¯»ä¹¦ç¬”è®°æ¿å— -->
                        <div v-if="activeNoteTab === 'reading'" class="note-editor">
                            <h3 style="margin-bottom:20px; color:#5a4a42; font-family:'Gochi Hand';">ğŸ“– æˆ‘çš„è¯»ä¹¦ç¬”è®°</h3>
                            
                            <!-- è¯»ä¹¦ç¬”è®°ç»Ÿè®¡ -->
                            <div class="reading-stats">
                                <div class="reading-stat">
                                    <div class="reading-stat-value">{{ totalReadingNotes }}</div>
                                    <div class="reading-stat-label">æ€»è¯»ä¹¦ç¬”è®°</div>
                                </div>
                                <div class="reading-stat">
                                    <div class="reading-stat-value">{{ averageRating.toFixed(1) }}</div>
                                    <div class="reading-stat-label">å¹³å‡è¯„åˆ†</div>
                                </div>
                                <div class="reading-stat">
                                    <div class="reading-stat-value">{{ totalAuthors }}</div>
                                    <div class="reading-stat-label">ä¸åŒä½œè€…</div>
                                </div>
                                <div class="reading-stat">
                                    <div class="reading-stat-value">{{ readingTags.length }}</div>
                                    <div class="reading-stat-label">æ ‡ç­¾æ•°é‡</div>
                                </div>
                            </div>
                            
                            <!-- è¯»ä¹¦ç¬”è®°ç­›é€‰å™¨ -->
                            <div class="reading-filter">
                                <div class="filter-group">
                                    <label>ğŸ” æœç´¢ä¹¦å/ä½œè€…</label>
                                    <input type="text" v-model="readingFilter.keyword" placeholder="è¾“å…¥å…³é”®è¯...">
                                </div>
                                
                                <div class="filter-group">
                                    <label>â­ è¯„åˆ†ç­›é€‰</label>
                                    <select v-model="readingFilter.minRating">
                                        <option value="0">å…¨éƒ¨è¯„åˆ†</option>
                                        <option value="5">5æ˜Ÿ</option>
                                        <option value="4">4æ˜ŸåŠä»¥ä¸Š</option>
                                        <option value="3">3æ˜ŸåŠä»¥ä¸Š</option>
                                        <option value="2">2æ˜ŸåŠä»¥ä¸Š</option>
                                        <option value="1">1æ˜ŸåŠä»¥ä¸Š</option>
                                    </select>
                                </div>
                                
                                <div class="filter-group">
                                    <label>ğŸ·ï¸ æ ‡ç­¾ç­›é€‰</label>
                                    <select v-model="readingFilter.selectedTag">
                                        <option value="">å…¨éƒ¨æ ‡ç­¾</option>
                                        <option v-for="tag in readingTags" :value="tag">{{ tag }}</option>
                                    </select>
                                </div>
                                
                                <div class="filter-group">
                                    <label>ğŸ“… æ’åºæ–¹å¼</label>
                                    <select v-model="readingFilter.sortBy">
                                        <option value="date">æœ€æ–°æ·»åŠ </option>
                                        <option value="rating">è¯„åˆ†æœ€é«˜</option>
                                        <option value="title">ä¹¦å A-Z</option>
                                    </select>
                                </div>
                                
                                <button class="btn-sm" @click="resetReadingFilters" style="align-self: flex-end; background:linear-gradient(90deg, #a3a3a3, #7a7a7a);">
                                    é‡ç½®ç­›é€‰
                                </button>
                            </div>
                            
                            <!-- è¯»ä¹¦ç¬”è®°ç¼–è¾‘å™¨ -->
                            <div class="reading-editor" v-if="!editingReadingNote">
                                <h4 style="margin-bottom:25px; color:#5a4a42; font-family:'Gochi Hand';">ğŸ“ æ·»åŠ æ–°è¯»ä¹¦ç¬”è®°</h4>
                                
                                <div class="reading-editor-section">
                                    <label for="bookTitle">ğŸ“š ä¹¦å</label>
                                    <input type="text" id="bookTitle" class="note-input" v-model="newReadingNote.title" placeholder="è¯·è¾“å…¥ä¹¦å...">
                                </div>
                                
                                <div class="reading-editor-section">
                                    <label for="bookAuthor">âœï¸ ä½œè€…</label>
                                    <input type="text" id="bookAuthor" class="note-input" v-model="newReadingNote.author" placeholder="è¯·è¾“å…¥ä½œè€…...">
                                </div>
                                
                                <div class="reading-editor-section">
                                    <label for="bookNotes">ğŸ“’ ç¬”è®°å†…å®¹</label>
                                    <textarea id="bookNotes" class="reading-textarea" v-model="newReadingNote.notes" placeholder="è®°å½•ä¹¦ä¸­çš„ç²¾å½©å†…å®¹ã€çŸ¥è¯†ç‚¹ã€æ‘˜å½•ç­‰..."></textarea>
                                </div>
                                
                                <div class="reading-editor-section">
                                    <label for="bookReflections">ğŸ’­ æˆ‘çš„æ„Ÿæ‚Ÿ</label>
                                    <textarea id="bookReflections" class="reading-textarea" v-model="newReadingNote.reflections" placeholder="è®°å½•é˜…è¯»åçš„æ€è€ƒã€æ„Ÿæ‚Ÿã€å¯å‘ç­‰..."></textarea>
                                </div>
                                
                                <div class="reading-editor-section">
                                    <label>â­ è¯„åˆ†</label>
                                    <div class="rating-display">
                                        <div class="rating-stars">
                                            <span 
                                                v-for="star in 5" 
                                                :key="star"
                                                class="star"
                                                :class="{ filled: star <= newReadingNote.rating }"
                                                @click="newReadingNote.rating = star"
                                            >
                                                â˜…
                                            </span>
                                        </div>
                                        <div class="rating-value">{{ newReadingNote.rating }} æ˜Ÿ</div>
                                    </div>
                                </div>
                                
                                <div class="reading-editor-section">
                                    <label for="bookTags">ğŸ·ï¸ æ ‡ç­¾</label>
                                    <input type="text" id="bookTags" class="note-input" v-model="newReadingNote.tagsInput" placeholder="æ·»åŠ æ ‡ç­¾ï¼Œç”¨é€—å·åˆ†éš” (ä¾‹å¦‚: å°è¯´, å¿ƒç†å­¦, æˆé•¿)">
                                </div>
                                
                                <div style="display:flex; gap:15px; margin-top:30px;">
                                    <button class="btn" @click="saveReadingNote" style="background:linear-gradient(90deg, #a3de83, #4ecdc4); width:auto; padding:14px 45px;">
                                        ğŸ’¾ ä¿å­˜è¯»ä¹¦ç¬”è®°
                                    </button>
                                    <button class="btn" @click="clearReadingEditor" 
                                            style="background:linear-gradient(90deg, #a3a3a3, #7a7a7a); width:auto; padding:14px 35px;">
                                        æ¸…ç©ºé‡å†™
                                    </button>
                                </div>
                            </div>
                            
                            <!-- è¯»ä¹¦ç¬”è®°ç¼–è¾‘æ¨¡å¼ -->
                            <div class="reading-editor" v-if="editingReadingNote">
                                <h4 style="margin-bottom:25px; color:#5a4a42; font-family:'Gochi Hand';">âœï¸ ç¼–è¾‘è¯»ä¹¦ç¬”è®°</h4>
                                
                                <div class="reading-editor-section">
                                    <label for="editBookTitle">ğŸ“š ä¹¦å</label>
                                    <input type="text" id="editBookTitle" class="note-input" v-model="editingReadingNote.title" placeholder="è¯·è¾“å…¥ä¹¦å...">
                                </div>
                                
                                <div class="reading-editor-section">
                                    <label for="editBookAuthor">âœï¸ ä½œè€…</label>
                                    <input type="text" id="editBookAuthor" class="note-input" v-model="editingReadingNote.author" placeholder="è¯·è¾“å…¥ä½œè€…...">
                                </div>
                                
                                <div class="reading-editor-section">
                                    <label for="editBookNotes">ğŸ“’ ç¬”è®°å†…å®¹</label>
                                    <textarea id="editBookNotes" class="reading-textarea" v-model="editingReadingNote.notes" placeholder="è®°å½•ä¹¦ä¸­çš„ç²¾å½©å†…å®¹ã€çŸ¥è¯†ç‚¹ã€æ‘˜å½•ç­‰..."></textarea>
                                </div>
                                
                                <div class="reading-editor-section">
                                    <label for="editBookReflections">ğŸ’­ æˆ‘çš„æ„Ÿæ‚Ÿ</label>
                                    <textarea id="editBookReflections" class="reading-textarea" v-model="editingReadingNote.reflections" placeholder="è®°å½•é˜…è¯»åçš„æ€è€ƒã€æ„Ÿæ‚Ÿã€å¯å‘ç­‰..."></textarea>
                                </div>
                                
                                <div class="reading-editor-section">
                                    <label>â­ è¯„åˆ†</label>
                                    <div class="rating-display">
                                        <div class="rating-stars">
                                            <span 
                                                v-for="star in 5" 
                                                :key="star"
                                                class="star"
                                                :class="{ filled: star <= editingReadingNote.rating }"
                                                @click="editingReadingNote.rating = star"
                                            >
                                                â˜…
                                            </span>
                                        </div>
                                        <div class="rating-value">{{ editingReadingNote.rating }} æ˜Ÿ</div>
                                    </div>
                                </div>
                                
                                <div class="reading-editor-section">
                                    <label for="editBookTags">ğŸ·ï¸ æ ‡ç­¾</label>
                                    <input type="text" id="editBookTags" class="note-input" v-model="editingReadingNote.tagsInput" placeholder="æ·»åŠ æ ‡ç­¾ï¼Œç”¨é€—å·åˆ†éš”">
                                </div>
                                
                                <div style="display:flex; gap:15px; margin-top:30px;">
                                    <button class="btn" @click="updateReadingNote" style="background:linear-gradient(90deg, #4a9fff, #2d73cc); width:auto; padding:14px 45px;">
                                        ğŸ’¾ æ›´æ–°è¯»ä¹¦ç¬”è®°
                                    </button>
                                    <button class="btn" @click="cancelEditReadingNote" 
                                            style="background:linear-gradient(90deg, #a3a3a3, #7a7a7a); width:auto; padding:14px 35px;">
                                        å–æ¶ˆç¼–è¾‘
                                    </button>
                                </div>
                            </div>
                            
                            <!-- è¯»ä¹¦ç¬”è®°åˆ—è¡¨ -->
                            <div v-if="filteredReadingNotes.length > 0" class="reading-notes-grid">
                                <div v-for="note in filteredReadingNotes" :key="note.id" class="reading-note-card">
                                    <div class="reading-note-header">
                                        <div>
                                            <div class="reading-note-title">{{ note.title }}</div>
                                            <div class="reading-note-author">ä½œè€…: {{ note.author }}</div>
                                        </div>
                                        <div class="rating-stars">
                                            <span 
                                                v-for="star in 5" 
                                                :key="star"
                                                class="star"
                                                :class="{ filled: star <= note.rating }"
                                            >
                                                â˜…
                                            </span>
                                        </div>
                                    </div>
                                    
                                    <div class="note-tags">
                                        <span class="note-tag" v-for="tag in note.tags" :key="tag">{{ tag }}</span>
                                    </div>
                                    
                                    <div class="reading-note-section">
                                        <h4>ğŸ“’ ç¬”è®°å†…å®¹</h4>
                                        <div class="reading-note-content">{{ note.notes }}</div>
                                    </div>
                                    
                                    <div class="reading-note-section">
                                        <h4>ğŸ’­ æˆ‘çš„æ„Ÿæ‚Ÿ</h4>
                                        <div class="reading-note-content">{{ note.reflections }}</div>
                                    </div>
                                    
                                    <div class="reading-note-meta">
                                        <div>
                                            <div>æ·»åŠ æ—¶é—´: {{ formatDate(note.createdAt) }}</div>
                                            <div>è¯„åˆ†: {{ note.rating }} æ˜Ÿ</div>
                                        </div>
                                        <div class="reading-note-actions">
                                            <button class="btn-sm" @click="editReadingNote(note.id)" style="background:linear-gradient(90deg, #4a9fff, #2d73cc);">
                                                ç¼–è¾‘
                                            </button>
                                            <button class="btn-sm" @click="deleteReadingNote(note.id)" style="background:linear-gradient(90deg, #ff7b6b, #d45d5d);">
                                                åˆ é™¤
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- ç©ºçŠ¶æ€æç¤º -->
                            <div v-if="filteredReadingNotes.length === 0" style="text-align:center; padding:50px 20px; color:#c9b8a7; margin-top: 30px;">
                                <div style="font-size:4em; margin-bottom:20px; transform:rotate(-5deg);">ğŸ“–</div>
                                <p style="font-weight:bold; font-size:1.3em; margin-bottom:10px;">è¿˜æ²¡æœ‰è¯»ä¹¦ç¬”è®°</p>
                                <p v-if="readingFilter.keyword || readingFilter.minRating > 0 || readingFilter.selectedTag">
                                    æ²¡æœ‰æ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„è¯»ä¹¦ç¬”è®°ï¼Œå°è¯•è°ƒæ•´ç­›é€‰æ¡ä»¶
                                </p>
                                <p v-else>ç‚¹å‡»ä¸Šæ–¹è¡¨å•æ·»åŠ ä½ çš„ç¬¬ä¸€æœ¬è¯»ä¹¦ç¬”è®°å§ï¼</p>
                            </div>
                        </div>
                        
                        <!-- æ€ç»´å¯¼å›¾ç¼–è¾‘å™¨ -->
                        <div v-if="activeNoteTab === 'mindmap'" class="note-editor">
                            <h3 style="margin-bottom:20px; color:#5a4a42; font-family:'Gochi Hand';">ğŸ§  åˆ›å»ºæ€ç»´å¯¼å›¾</h3>
                            
                            <div class="mindmap-controls">
                                <input 
                                    type="text" 
                                    v-model="mindmapNodeText" 
                                    class="mindmap-input" 
                                    placeholder="è¾“å…¥èŠ‚ç‚¹å†…å®¹..."
                                    @keyup.enter="addMindmapNode"
                                >
                                <button class="btn-sm" @click="addMindmapNode" style="background:linear-gradient(90deg, #a3de83, #4ecdc4);">
                                    â• æ·»åŠ èŠ‚ç‚¹
                                </button>
                                <button class="btn-sm" @click="selectMindmapNode(null)" :style="{background: mindmapSelectedNode === null ? '#ff9a8b' : 'linear-gradient(90deg, #4a9fff, #2d73cc)'}">
                                    ğŸ¯ {{ mindmapSelectedNode === null ? 'é€‰æ‹©æ ¹èŠ‚ç‚¹' : 'å–æ¶ˆé€‰æ‹©' }}
                                </button>
                                <button class="btn-sm" @click="clearMindmap" style="background:linear-gradient(90deg, #ff7b6b, #d45d5d);">
                                    ğŸ—‘ï¸ æ¸…ç©º
                                </button>
                                <button class="btn-sm" @click="saveMindmapAsNote" style="background:linear-gradient(90deg, #4a9fff, #2d73cc);">
                                    ğŸ’¾ ä¿å­˜ä¸ºç¬”è®°
                                </button>
                                <button class="btn-sm" @click="loadSampleMindmap" style="background:linear-gradient(90deg, #ffd166, #ffb347); color:#5a4a42;">
                                    ğŸ“‹ åŠ è½½ç¤ºä¾‹
                                </button>
                            </div>
                            
                            <div style="margin: 15px 0; padding: 10px; background: #fffaf5; border-radius: 10px; border: 2px dashed #ffc8a3;">
                                <p style="font-weight: bold; color: #5a4a42; margin-bottom: 5px;">å½“å‰é€‰ä¸­èŠ‚ç‚¹: 
                                    <span v-if="mindmapSelectedNode">
                                        {{ mindmapNodes.find(n => n.id === mindmapSelectedNode)?.text || 'æ— ' }}
                                        <button class="btn-sm" @click="toggleRootNode(mindmapSelectedNode)" style="margin-left: 10px; padding: 3px 10px; font-size: 0.8em;">
                                            {{ mindmapRootNode === mindmapSelectedNode ? 'ğŸ‘‘ å–æ¶ˆæ ¹èŠ‚ç‚¹' : 'ğŸ‘‘ è®¾ä¸ºæ ¹èŠ‚ç‚¹' }}
                                        </button>
                                    </span>
                                    <span v-else>æ— ï¼ˆç‚¹å‡»èŠ‚ç‚¹è¿›è¡Œé€‰æ‹©ï¼‰</span>
                                </p>
                                <p style="font-size: 0.9em; color: #7a6a62;">ğŸ’¡ æç¤ºï¼šå…ˆé€‰ä¸­ä¸€ä¸ªèŠ‚ç‚¹ï¼Œç„¶åæ·»åŠ æ–°èŠ‚ç‚¹ä¼šè‡ªåŠ¨æˆä¸ºå…¶å­èŠ‚ç‚¹</p>
                            </div>
                            
                            <!-- æ€ç»´å¯¼å›¾èŠ‚ç‚¹åˆ—è¡¨ -->
                            <div class="mindmap-nodes-list" v-if="mindmapNodes.length > 0">
                                <h4 style="margin-bottom:10px; color:#5a4a42;">èŠ‚ç‚¹åˆ—è¡¨ ({{ mindmapNodes.length }})</h4>
                                <div v-for="(node, index) in mindmapNodes" :key="node.id" class="mindmap-node-item" :style="{borderLeftColor: mindmapSelectedNode === node.id ? '#ff6b6b' : '#ff9a8b'}">
                                    <div>
                                        <strong>{{ node.text }}</strong>
                                        <div style="font-size:0.8em; color:#7a6a62;">
                                            å±‚çº§: {{ node.level }} | 
                                            å­èŠ‚ç‚¹: {{ node.children?.length || 0 }} |
                                            <span v-if="mindmapRootNode === node.id">ğŸ‘‘ æ ¹èŠ‚ç‚¹</span>
                                        </div>
                                    </div>
                                    <div style="display:flex; gap:5px;">
                                        <button class="toolbar-btn" @click="selectMindmapNode(node.id)" :style="{background: mindmapSelectedNode === node.id ? '#ff9a8b' : '#fffefc'}">
                                            {{ mindmapSelectedNode === node.id ? 'âœ“ å·²é€‰' : 'é€‰æ‹©' }}
                                        </button>
                                        <button class="toolbar-btn" @click="toggleRootNode(node.id)" :style="{background: mindmapRootNode === node.id ? '#ffd166' : '#fffefc'}">
                                            {{ mindmapRootNode === node.id ? 'ğŸ‘‘' : 'è®¾ä¸ºæ ¹' }}
                                        </button>
                                        <button class="toolbar-btn" @click="editMindmapNode(index)" style="padding:4px 10px; font-size:0.8em;">ç¼–è¾‘</button>
                                        <button class="toolbar-btn" @click="removeMindmapNode(index)" style="padding:4px 10px; font-size:0.8em; background:#ffd6cc;">åˆ é™¤</button>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- æ€ç»´å¯¼å›¾ç”»å¸ƒ -->
                            <div class="mindmap-container" ref="mindmapContainer" @click="addNodeAtPosition">
                                <div 
                                    v-for="node in mindmapNodes" 
                                    :key="node.id"
                                    class="mindmap-node"
                                    :style="{
                                        left: node.x + 'px',
                                        top: node.y + 'px',
                                        backgroundColor: node.color || '#fffefc',
                                        borderColor: mindmapSelectedNode === node.id ? '#ff6b6b' : (mindmapRootNode === node.id ? '#ffd166' : '#5a4a42'),
                                        boxShadow: mindmapSelectedNode === node.id ? '0 0 10px #ff6b6b' : '3px 3px 0px #d4b8a7'
                                    }"
                                    @mousedown="startNodeDrag(node, $event)"
                                    @dblclick="editMindmapNodeById(node.id)"
                                    @click="selectMindmapNode(node.id)"
                                >
                                    {{ node.text }}
                                    <div v-if="mindmapRootNode === node.id" style="position: absolute; top: -5px; right: -5px; font-size: 12px; background: #ffd166; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center;">ğŸ‘‘</div>
                                </div>
                                
                                <!-- è¿æ¥çº¿ -->
                                <svg width="100%" height="100%" style="position:absolute; top:0; left:0; pointer-events:none;">
                                    <line 
                                        v-for="(line, index) in mindmapLines" 
                                        :key="index"
                                        :x1="line.x1" 
                                        :y1="line.y1" 
                                        :x2="line.x2" 
                                        :y2="line.y2"
                                        :stroke="line.type === 'parent-child' ? '#4ecdc4' : '#ff9a8b'" 
                                        stroke-width="2"
                                        :stroke-dasharray="line.type === 'parent-child' ? 'none' : '5,5'"
                                    />
                                </svg>
                            </div>
                            
                            <div style="margin-top:20px; padding:15px; background:#fffaf5; border-radius:10px;">
                                <p style="font-weight:bold; color:#5a4a42; margin-bottom:10px;">ğŸ’¡ ä½¿ç”¨æç¤ºï¼š</p>
                                <ul style="color:#7a6a62; font-size:0.9em;">
                                    <li>ç‚¹å‡»èŠ‚ç‚¹é€‰æ‹©å®ƒï¼Œç„¶åæ·»åŠ æ–°èŠ‚ç‚¹ä¼šæˆä¸ºå…¶å­èŠ‚ç‚¹</li>
                                    <li>åŒå‡»èŠ‚ç‚¹å¯ä»¥ç¼–è¾‘å†…å®¹</li>
                                    <li>æ‹–åŠ¨èŠ‚ç‚¹å¯ä»¥é‡æ–°å¸ƒå±€</li>
                                    <li>ç‚¹å‡»"è®¾ä¸ºæ ¹èŠ‚ç‚¹"è®¾ç½®ä¸­å¿ƒèŠ‚ç‚¹</li>
                                    <li>ç»¿è‰²çº¿è¡¨ç¤ºçˆ¶å­å…³ç³»ï¼Œæ©™è‰²çº¿è¡¨ç¤ºè¿æ¥åˆ°æ ¹èŠ‚ç‚¹</li>
                                </ul>
                            </div>
                        </div>
                        
                        <!-- é«˜äº®å†…å®¹æå– -->
                        <div v-if="activeNoteTab === 'highlights'" class="note-editor">
                            <h3 style="margin-bottom:20px; color:#5a4a42; font-family:'Gochi Hand';">ğŸŒŸ é«˜äº®å†…å®¹æå–ä¸­å¿ƒ</h3>
                            
                            <div style="margin-bottom: 30px;">
                                <div style="display: flex; gap: 15px; align-items: center; margin-bottom: 20px;">
                                    <select v-model="highlightSourceNote" class="note-input" style="flex-grow:1;">
                                        <option value="">é€‰æ‹©ç¬”è®°æ¥æº...</option>
                                        <option v-for="note in notes" :value="note.id">{{ note.title }}</option>
                                    </select>
                                    <button class="btn-sm" @click="extractHighlights" style="background:linear-gradient(90deg, #a3de83, #4ecdc4);">
                                        ğŸ” æå–é«˜äº®
                                    </button>
                                    <button class="btn-sm" @click="extractAllHighlights" style="background:linear-gradient(90deg, #4a9fff, #2d73cc);">
                                        ğŸŒ æå–æ‰€æœ‰ç¬”è®°
                                    </button>
                                </div>
                                
                                <div v-if="extractedHighlights.length > 0" class="highlight-extract-panel">
                                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
                                        <h4 style="color:#5a4a42;">å·²æå– {{ extractedHighlights.length }} ä¸ªé«˜äº®</h4>
                                        <div style="display:flex; gap:10px;">
                                            <button class="btn-sm" @click="createNoteFromHighlights" style="background:linear-gradient(90deg, #a3de83, #4ecdc4);">
                                                ğŸ“ ç”Ÿæˆæ–°ç¬”è®°
                                            </button>
                                            <button class="btn-sm" @click="clearHighlights" style="background:linear-gradient(90deg, #a3a3a3, #7a7a7a);">
                                                æ¸…ç©º
                                            </button>
                                        </div>
                                    </div>
                                    
                                    <div v-for="(highlight, index) in extractedHighlights" :key="index" class="highlight-item">
                                        <div class="highlight-content" v-html="highlight.content"></div>
                                        <div class="highlight-actions">
                                            <button class="toolbar-btn" @click="copyHighlight(highlight)" style="padding:6px 12px;">ğŸ“‹</button>
                                            <button class="toolbar-btn" @click="removeHighlight(index)" style="padding:6px 12px; background:#ffd6cc;">ğŸ—‘ï¸</button>
                                        </div>
                                        <div class="highlight-source">
                                            æ¥æº: {{ highlight.sourceTitle }}
                                        </div>
                                    </div>
                                    
                                    <div style="margin-top: 25px; padding-top: 20px; border-top: 2px dashed #ffc8a3;">
                                        <textarea 
                                            v-model="newNoteFromHighlights" 
                                            class="note-input" 
                                            placeholder="åœ¨è¿™é‡Œç¼–è¾‘é«˜äº®ç¬”è®°å†…å®¹..."
                                            rows="6"
                                        ></textarea>
                                        <div style="display:flex; gap:15px; margin-top:15px;">
                                            <button class="btn" @click="saveHighlightsNote" style="width:auto; padding:12px 30px;">
                                                ğŸ’¾ ä¿å­˜ä¸ºç¬”è®°
                                            </button>
                                        </div>
                                    </div>
                                </div>
                                
                                <div v-else style="text-align:center; padding:40px 20px; color:#c9b8a7;">
                                    <div style="font-size:3.5em; margin-bottom:15px; transform:rotate(-5deg);">ğŸŒŸ</div>
                                    <p style="font-weight:bold; font-size:1.2em;">è¿˜æ²¡æœ‰æå–åˆ°é«˜äº®å†…å®¹</p>
                                    <p>é€‰æ‹©ä¸€ä¸ªç¬”è®°ï¼Œç„¶åç‚¹å‡»"æå–é«˜äº®"æŒ‰é’®</p>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Wordå¼æ–‡æ¡£é¢„è§ˆ -->
                        <div v-if="activeNoteTab === 'wordview'" class="note-editor">
                            <h3 style="margin-bottom:20px; color:#5a4a42; font-family:'Gochi Hand';">ğŸ“„ Wordå¼æ–‡æ¡£é¢„è§ˆ</h3>
                            
                            <div style="margin-bottom: 25px; display: flex; gap: 15px;">
                                <select v-model="selectedNoteForPreview" class="note-input" style="flex-grow:1;">
                                    <option value="">é€‰æ‹©è¦é¢„è§ˆçš„ç¬”è®°...</option>
                                    <option v-for="note in notes" :value="note.id">{{ note.title }}</option>
                                </select>
                                <button class="btn-sm" @click="printPreview" style="background:linear-gradient(90deg, #4a9fff, #2d73cc);">
                                    ğŸ–¨ï¸ æ‰“å°é¢„è§ˆ
                                </button>
                                <button class="btn-sm" @click="exportAsDocument" style="background:linear-gradient(90deg, #a3de83, #4ecdc4);">
                                    ğŸ’¾ å¯¼å‡ºæ–‡æ¡£
                                </button>
                            </div>
                            
                            <div v-if="selectedNoteForPreview" class="word-document">
                                <div class="word-header">
                                    <h1 style="font-family:'Gochi Hand', cursive; color:#5a4a42; margin-bottom:10px;">
                                        {{ getNoteById(selectedNoteForPreview).title }}
                                    </h1>
                                    <div style="color:#7a6a62; font-size:0.9em;">
                                        åˆ›å»ºäº: {{ formatDate(getNoteById(selectedNoteForPreview).createdAt) }}
                                    </div>
                                </div>
                                
                                <div class="word-content" v-html="getNoteById(selectedNoteForPreview).content"></div>
                                
                                <div class="word-page-number">
                                    ç¬¬ 1 é¡µ
                                </div>
                            </div>
                            
                            <div v-else style="text-align:center; padding:40px 20px; color:#c9b8a7;">
                                <div style="font-size:3.5em; margin-bottom:15px; transform:rotate(-5deg);">ğŸ“„</div>
                                <p style="font-weight:bold; font-size:1.2em;">é€‰æ‹©ç¬”è®°ä»¥é¢„è§ˆ</p>
                                <p>ä»ä¸‹æ‹‰åˆ—è¡¨ä¸­é€‰æ‹©ä¸€ä¸ªç¬”è®°æŸ¥çœ‹Wordå¼æ–‡æ¡£æ•ˆæœ</p>
                            </div>
                        </div>
                        
                        <!-- ç¬”è®°åˆ—è¡¨ï¼šå…¶ä»–æ ‡ç­¾é¡µæ—¶æ˜¾ç¤º -->
                        <div v-if="!['editor', 'reading', 'mindmap', 'highlights', 'wordview'].includes(activeNoteTab)" class="note-list">
                            <div v-for="note in filteredAndSortedNotes" :key="note.id" class="note-card">
                                <h3 style="margin-bottom:18px; color:#5a4a42; font-family:'Gochi Hand'; font-size:1.6em;">{{ note.title }}</h3>
                                <div class="note-tags">
                                    <span class="note-tag" v-for="tag in note.tags" :key="tag">{{ tag }}</span>
                                </div>
                                
                                <!-- å¯Œæ–‡æœ¬å†…å®¹æ¸²æŸ“ -->
                                <div 
                                    class="note-content-rich" 
                                    v-html="sanitizeHtml(note.content)"
                                    style="color:#5a4a42; line-height:1.7; margin:25px 0; white-space: pre-line;"
                                ></div>
                                
                                <!-- æ˜¾ç¤ºå›¾ç‰‡ -->
                                <div v-if="note.imageData || note.imageUrl" style="margin-top:25px;">
                                    <img :src="note.imageData || note.imageUrl" alt="ç¬”è®°å›¾ç‰‡" class="note-image" @error="handleImageError">
                                </div>
                                
                                <!-- ç¬”è®°æ“ä½œåŒº -->
                                <div style="display:flex; justify-content:space-between; align-items:center; margin-top:30px; padding-top:25px; border-top:3px dotted #e0c9b8;">
                                    <div style="font-size:0.95em; color:#7a6a62; font-weight:bold;">
                                        ğŸ“… {{ formatDate(note.createdAt) }}
                                        <span style="margin-left:15px; background:#ffd6cc; padding:3px 10px; border-radius:10px; border:1px dashed #ff9a8b;">
                                            {{ getCategoryDisplayName(note.category) }}
                                        </span>
                                        <span v-if="hasHighlights(note)" style="margin-left:10px; background:#ffd6cc; padding:3px 10px; border-radius:10px; border:1px dashed #ff9a8b; color:#ff6b6b;">
                                            ğŸŒŸ æœ‰é«˜äº®
                                        </span>
                                    </div>
                                    <div style="display:flex; gap:10px;">
                                        <button class="btn-sm" @click="editNote(note.id)" style="background:linear-gradient(90deg, #4a9fff, #2d73cc);">
                                            ç¼–è¾‘
                                        </button>
                                        <button class="btn-sm" @click="extractHighlightsFromNote(note.id)" style="background:linear-gradient(90deg, #ffd166, #ffb347); color:#5a4a42;">
                                            æå–é«˜äº®
                                        </button>
                                        <button class="btn-sm" @click="deleteNote(note.id)" style="background:linear-gradient(90deg, #ff7b6b, #d45d5d);">
                                            åˆ é™¤
                                        </button>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- ç©ºçŠ¶æ€æç¤º -->
                            <div v-if="filteredAndSortedNotes.length === 0" style="text-align:center; padding:50px 20px; color:#c9b8a7; grid-column: 1 / -1;">
                                <div style="font-size:4em; margin-bottom:20px; transform:rotate(-5deg);">ğŸ“</div>
                                <p style="font-weight:bold; font-size:1.3em; margin-bottom:10px;">æ²¡æœ‰æ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„ç¬”è®°</p>
                                <p>å°è¯•è°ƒæ•´ç­›é€‰æ¡ä»¶æˆ–åˆ‡æ¢åˆ°å…¶ä»–æ ‡ç­¾å¼€å§‹è®°å½•å§ï¼</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- æˆé•¿æ¦‚è§ˆ -->
            <div class="card" style="margin-top: 50px;">
                <h2>ğŸ“ˆ æˆé•¿æ¦‚è§ˆ</h2>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="stat-value">{{ totalXpEarned }}</div>
                        <div class="stat-label">ç´¯è®¡è·å¾—ç»éªŒ</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value">{{ totalSkills }}</div>
                        <div class="stat-label">æŠ€èƒ½æ•°é‡</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value">{{ totalNotes }}</div>
                        <div class="stat-label">ç¬”è®°æ•°é‡</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value">{{ totalReadingNotes }}</div>
                        <div class="stat-label">è¯»ä¹¦ç¬”è®°</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value">{{ completedAchievementsCount }}</div>
                        <div class="stat-label">æˆå°±è¾¾æˆ</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value">{{ totalHighlights }}</div>
                        <div class="stat-label">é«˜äº®å†…å®¹</div>
                    </div>
                </div>
                <p style="text-align:center; margin-top:35px; padding-top:30px; border-top:3px dotted #ffc8a3; color:#7a6a62; font-size:1em; font-weight:bold;">
                    æ‰€æœ‰æ•°æ®é€šè¿‡GitHub APIåŒæ­¥è‡³ä½ çš„ç§æœ‰ä»“åº“ï¼ŒåŒ…å«å¯Œæ–‡æœ¬ç¬”è®°å’Œæ€ç»´å¯¼å›¾åŠŸèƒ½ã€‚
                </p>
            </div>
        </div>
    </div>

    <script>
        // Vue 3 åº”ç”¨ - å¢å¼ºç‰ˆæ™ºèƒ½æ‰‹è´¦ç³»ç»Ÿ
        const { createApp, ref, computed, onMounted, nextTick } = Vue;

        createApp({
            setup() {
                // ==================== çŠ¶æ€ä¸é…ç½® ====================
                const isConfigured = ref(false);
                const showConfig = ref(false);
                const showImport = ref(false);
                const isSaving = ref(false);
                const isLoading = ref(false);
                const configError = ref('');
                const lastSyncTime = ref('');
                const statusMessage = ref(null);
                
                // ç”¨æˆ·é…ç½®
                const config = ref({
                    username: '',
                    repo: '',
                    token: ''
                });

                // æ ¸å¿ƒæ¸¸æˆæ•°æ®
                const player = ref({ level: 1, xp: 0, nextLevelXp: 100, streak: 1 });
                const skills = ref([]);
                const notes = ref([]);
                const readingNotes = ref([]); // æ–°å¢ï¼šè¯»ä¹¦ç¬”è®°æ•°æ®
                const activeAchievementTab = ref('all');
                const activeNoteTab = ref('editor');
                const noteCategories = ref(['all', 'editor', 'reading', 'mindmap', 'highlights', 'wordview']);
                const newNote = ref({ 
                    title: '', 
                    content: '', 
                    tagsInput: '', 
                    imageData: null,
                    category: 'general' 
                });
                
                // æ–°å¢ï¼šè¯»ä¹¦ç¬”è®°ç¼–è¾‘çŠ¶æ€
                const newReadingNote = ref({
                    title: '',
                    author: '',
                    notes: '',
                    reflections: '',
                    rating: 0,
                    tagsInput: ''
                });
                
                const editingReadingNote = ref(null);
                const readingFilter = ref({
                    keyword: '',
                    minRating: 0,
                    selectedTag: '',
                    sortBy: 'date'
                });
                
                // æ–°å¢ï¼šæŠ˜å çŠ¶æ€
                const collapseStatus = ref(false);
                const collapseSkills = ref(false);
                const collapseAchievements = ref(false);
                const collapseNotes = ref(false);
                const showBatchAdd = ref(false);
                const batchAchievementInput = ref('');
                
                // æ–°å¢ï¼šå¯Œæ–‡æœ¬ç¼–è¾‘çŠ¶æ€
                const editorFocused = ref(false);
                const activeFormat = ref('');
                const textColor = ref('#5a4a42');
                const fontSize = ref('16');
                const richTextEditor = ref(null);
                
                // æ–°å¢ï¼šæ€ç»´å¯¼å›¾çŠ¶æ€ï¼ˆå·²æ›´æ–°ï¼‰
                const mindmapNodeText = ref('');
                const mindmapNodes = ref([]);
                const mindmapLines = ref([]);
                const mindmapContainer = ref(null);
                const draggingNode = ref(null);
                const dragOffset = ref({ x: 0, y: 0 });
                const mindmapSelectedNode = ref(null);
                const mindmapRootNode = ref(null);
                
                // æ–°å¢ï¼šé«˜äº®æå–çŠ¶æ€
                const extractedHighlights = ref([]);
                const highlightSourceNote = ref('');
                const newNoteFromHighlights = ref('');
                const selectedNoteForPreview = ref('');
                
                // ç¬”è®°ç­›é€‰å™¨
                const noteFilter = ref({
                    timeRange: 'all',
                    selectedTag: '',
                    selectedCategory: '',
                    keyword: '',
                    formatType: ''
                });
                
                // æˆå°±ç³»ç»Ÿæ•°æ®
                const achievements = ref([
                    { id: 1, category: 'yixue', name: 'å…«å­—å…¥é—¨', icon: 'ğŸŒŒ', description: 'å®Œæˆ10æ¬¡å…«å­—å­¦ä¹ ', requirement: 10, current: 0, unlocked: false, reward: 100 },
                    { id: 2, category: 'yixue', name: 'å…­çˆ»åˆæ¢', icon: 'â˜¯ï¸', description: 'å®Œæˆ10æ¬¡å…­çˆ»å­¦ä¹ ', requirement: 10, current: 0, unlocked: false, reward: 100 },
                    { id: 3, category: 'yixue', name: 'é£æ°´åŸºç¡€', icon: 'ğŸï¸', description: 'å®Œæˆ10æ¬¡é£æ°´å­¦ä¹ ', requirement: 10, current: 0, unlocked: false, reward: 100 },
                    { id: 4, category: 'yixue', name: 'å¥‡é—¨å…¥é—¨', icon: 'ğŸŒ€', description: 'å®Œæˆ10æ¬¡å¥‡é—¨å­¦ä¹ ', requirement: 10, current: 0, unlocked: false, reward: 100 },
                    { id: 5, category: 'yixue', name: 'æ‹©æ—¥åˆå­¦', icon: 'ğŸ“…', description: 'å®Œæˆ10æ¬¡æ‹©æ—¥å­¦ä¹ ', requirement: 10, current: 0, unlocked: false, reward: 100 },
                    { id: 6, category: 'english', name: 'é«˜ä¸­æ°´å¹³', icon: 'ğŸ“', description: 'æŒæ¡3000ä¸ªè‹±è¯­å•è¯', requirement: 3000, current: 0, unlocked: false, reward: 150 },
                    { id: 7, category: 'english', name: 'å››çº§æ°´å¹³', icon: 'ğŸ“˜', description: 'æŒæ¡5000ä¸ªè‹±è¯­å•è¯', requirement: 5000, current: 0, unlocked: false, reward: 250 },
                    { id: 8, category: 'english', name: 'å…­çº§æ°´å¹³', icon: 'ğŸ“—', description: 'æŒæ¡6500ä¸ªè‹±è¯­å•è¯', requirement: 6500, current: 0, unlocked: false, reward: 400 },
                    { id: 9, category: 'fitness', name: 'è¿åŠ¨æ–°æ‰‹', icon: 'ğŸ’ª', description: 'å®Œæˆ30æ¬¡å¥èº«è¿åŠ¨', requirement: 30, current: 0, unlocked: false, reward: 120 },
                    { id: 10, category: 'fitness', name: 'å¥èº«è¾¾äºº', icon: 'ğŸ‹ï¸', description: 'å®Œæˆ100æ¬¡å¥èº«è¿åŠ¨', requirement: 100, current: 0, unlocked: false, reward: 300 },
                    { id: 11, category: 'meditation', name: 'å†¥æƒ³åˆä½“éªŒ', icon: 'ğŸ§˜', description: 'å®Œæˆ20æ¬¡å†¥æƒ³ç»ƒä¹ ', requirement: 20, current: 0, unlocked: false, reward: 80 },
                    { id: 12, category: 'meditation', name: 'å¿ƒçµå¹³é™', icon: 'ğŸŒ¿', description: 'å®Œæˆ50æ¬¡å†¥æƒ³ç»ƒä¹ ', requirement: 50, current: 0, unlocked: false, reward: 200 },
                    { id: 13, category: 'skill', name: 'å¤šé¢æ‰‹', icon: 'ğŸ”§', description: 'æ‹¥æœ‰5ä¸ªä¸åŒæŠ€èƒ½', requirement: 5, current: 0, unlocked: false, reward: 150 },
                    { id: 14, category: 'skill', name: 'æŠ€èƒ½å¤§å¸ˆ', icon: 'ğŸ‘‘', description: 'æ‹¥æœ‰3ä¸ªè¾¾åˆ°5çº§çš„æŠ€èƒ½', requirement: 3, current: 0, unlocked: false, reward: 500 },
                    { id: 15, category: 'reading', name: 'é˜…è¯»çˆ±å¥½è€…', icon: 'ğŸ“š', description: 'å®Œæˆ10ç¯‡è¯»ä¹¦ç¬”è®°', requirement: 10, current: 0, unlocked: false, reward: 200 },
                    { id: 16, category: 'reading', name: 'æ·±åº¦é˜…è¯»è€…', icon: 'ğŸ“–', description: 'å®Œæˆ30ç¯‡è¯»ä¹¦ç¬”è®°', requirement: 30, current: 0, unlocked: false, reward: 500 }
                ]);

                // ==================== æ™ºèƒ½åˆ†ç±»é…ç½® ====================
                const categoryRules = {
                    'bazi': ['å…«å­—', 'å‘½ç†', 'åç¥', 'å¹²æ”¯', 'äº”è¡Œ'],
                    'stock': ['è‚¡ç¥¨', 'å¤ç›˜', 'kçº¿', 'ç‚’è‚¡', 'å¤§ç›˜', 'Aè‚¡'],
                    'fitness': ['å¥èº«', 'è¿åŠ¨', 'è·‘æ­¥', 'æ’¸é“', 'å¢è‚Œ', 'å‡è„‚'],
                    'english': ['è‹±è¯­', 'å•è¯', 'é˜…è¯»', 'å¬åŠ›', 'å£è¯­', 'é›…æ€'],
                    'daily': ['æ¯æ—¥', 'æ—¥è®°', 'æ€»ç»“', 'åæ€', 'è®¡åˆ’', 'æ—¥å¸¸'],
                    'work': ['å·¥ä½œ', 'é¡¹ç›®', 'ä»»åŠ¡', 'æ±‡æŠ¥', 'ä¼šè®®', 'èŒåœº'],
                    'study': ['å­¦ä¹ ', 'è¯»ä¹¦', 'è¯¾ç¨‹', 'è€ƒè¯•', 'è®ºæ–‡', 'çŸ¥è¯†'],
                    'reading': ['è¯»ä¹¦', 'é˜…è¯»', 'ä¹¦ç±', 'å°è¯´', 'æ–‡å­¦', 'çŸ¥è¯†']
                };

                const categoryDisplayNames = {
                    'all': 'å…¨éƒ¨',
                    'editor': 'å¯Œæ–‡æœ¬ç¼–è¾‘',
                    'reading': 'è¯»ä¹¦ç¬”è®°',
                    'mindmap': 'æ€ç»´å¯¼å›¾',
                    'highlights': 'é«˜äº®æå–',
                    'wordview': 'Wordé¢„è§ˆ',
                    'bazi': 'å…«å­—å¤ç›˜',
                    'stock': 'è‚¡ç¥¨å¤ç›˜',
                    'fitness': 'å¥èº«è®°å½•',
                    'english': 'è‹±è¯­å­¦ä¹ ',
                    'daily': 'æ¯æ—¥å¤ç›˜',
                    'work': 'å·¥ä½œç¬”è®°',
                    'study': 'å­¦ä¹ ç¬”è®°',
                    'general': 'ä¸€èˆ¬ç¬”è®°',
                    'custom': 'è‡ªå®šä¹‰æˆå°±'
                };

                // ==================== è®¡ç®—å±æ€§ ====================
                const totalXpEarned = computed(() => {
                    let total = player.value.xp;
                    skills.value.forEach(skill => total += skill.xp);
                    achievements.value.forEach(ach => {
                        if (ach.unlocked) total += ach.reward;
                    });
                    return total;
                });

                const totalSkills = computed(() => skills.value.length);
                const totalNotes = computed(() => notes.value.length);
                const totalReadingNotes = computed(() => readingNotes.value.length);
                const completedAchievementsCount = computed(() => 
                    achievements.value.filter(a => a.unlocked).length
                );

                // è®¡ç®—é«˜äº®å†…å®¹æ€»æ•°
                const totalHighlights = computed(() => {
                    let count = 0;
                    notes.value.forEach(note => {
                        if (note.content && note.content.includes('highlight')) {
                            // ç®€å•ç»Ÿè®¡é«˜äº®æ ‡ç­¾
                            const matches = note.content.match(/<span class="highlight">/g) || 
                                          note.content.match(/<mark>/g) ||
                                          note.content.match(/class="highlight"/g);
                            if (matches) count += matches.length;
                        }
                    });
                    return count;
                });

                // æ‰€æœ‰ç¬”è®°æ ‡ç­¾
                const allNoteTags = computed(() => {
                    const tags = new Set();
                    notes.value.forEach(note => {
                        if (note.tags && Array.isArray(note.tags)) {
                            note.tags.forEach(tag => tags.add(tag));
                        }
                    });
                    return Array.from(tags).sort();
                });

                // è¯»ä¹¦ç¬”è®°ç›¸å…³è®¡ç®—å±æ€§
                const readingTags = computed(() => {
                    const tags = new Set();
                    readingNotes.value.forEach(note => {
                        if (note.tags && Array.isArray(note.tags)) {
                            note.tags.forEach(tag => tags.add(tag));
                        }
                    });
                    return Array.from(tags).sort();
                });

                const totalAuthors = computed(() => {
                    const authors = new Set();
                    readingNotes.value.forEach(note => {
                        if (note.author) {
                            authors.add(note.author);
                        }
                    });
                    return authors.size;
                });

                const averageRating = computed(() => {
                    if (readingNotes.value.length === 0) return 0;
                    const total = readingNotes.value.reduce((sum, note) => sum + (note.rating || 0), 0);
                    return total / readingNotes.value.length;
                });

                // è¿‡æ»¤åçš„è¯»ä¹¦ç¬”è®°
                const filteredReadingNotes = computed(() => {
                    let filtered = [...readingNotes.value];
                    const filter = readingFilter.value;
                    
                    // å…³é”®è¯æœç´¢
                    if (filter.keyword) {
                        const keyword = filter.keyword.toLowerCase();
                        filtered = filtered.filter(note => 
                            note.title.toLowerCase().includes(keyword) || 
                            note.author.toLowerCase().includes(keyword) ||
                            note.notes.toLowerCase().includes(keyword) ||
                            note.reflections.toLowerCase().includes(keyword) ||
                            (note.tags && note.tags.some(tag => tag.toLowerCase().includes(keyword)))
                        );
                    }
                    
                    // è¯„åˆ†ç­›é€‰
                    if (filter.minRating > 0) {
                        filtered = filtered.filter(note => note.rating >= filter.minRating);
                    }
                    
                    // æ ‡ç­¾ç­›é€‰
                    if (filter.selectedTag) {
                        filtered = filtered.filter(note => 
                            note.tags && note.tags.includes(filter.selectedTag)
                        );
                    }
                    
                    // æ’åº
                    switch(filter.sortBy) {
                        case 'date':
                            filtered.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                            break;
                        case 'rating':
                            filtered.sort((a, b) => b.rating - a.rating);
                            break;
                        case 'title':
                            filtered.sort((a, b) => a.title.localeCompare(b.title));
                            break;
                    }
                    
                    return filtered;
                });

                // è¿‡æ»¤åçš„æˆå°±
                const filteredAchievements = computed(() => {
                    if (activeAchievementTab.value === 'all') return achievements.value;
                    return achievements.value.filter(a => a.category === activeAchievementTab.value);
                });

                // æ–°å¢ï¼šè¿‡æ»¤å’Œæ’åºåçš„ç¬”è®°ï¼ˆæ”¯æŒæ ¼å¼ç­›é€‰ï¼‰
                const filteredAndSortedNotes = computed(() => {
                    let filtered = notes.value;
                    
                    // æŒ‰åˆ†ç±»ç­›é€‰
                    if (activeNoteTab.value !== 'all' && !['editor', 'reading', 'mindmap', 'highlights', 'wordview'].includes(activeNoteTab.value)) {
                        filtered = filtered.filter(note => {
                            if (note.category === activeNoteTab.value) return true;
                            const keywords = categoryRules[activeNoteTab.value];
                            if (keywords && note.tags) {
                                return note.tags.some(tag => 
                                    keywords.some(keyword => tag.toLowerCase().includes(keyword.toLowerCase()))
                                );
                            }
                            return false;
                        });
                    }
                    
                    // åº”ç”¨ç­›é€‰å™¨
                    const filter = noteFilter.value;
                    
                    // æ—¶é—´èŒƒå›´ç­›é€‰
                    if (filter.timeRange !== 'all') {
                        const now = new Date();
                        filtered = filtered.filter(note => {
                            const noteDate = new Date(note.createdAt);
                            switch(filter.timeRange) {
                                case 'today':
                                    return noteDate.toDateString() === now.toDateString();
                                case 'week':
                                    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                                    return noteDate >= weekAgo;
                                case 'month':
                                    const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                                    return noteDate >= monthAgo;
                                case 'year':
                                    const yearAgo = new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000);
                                    return noteDate >= yearAgo;
                                default:
                                    return true;
                            }
                        });
                    }
                    
                    // æ ‡ç­¾ç­›é€‰
                    if (filter.selectedTag) {
                        filtered = filtered.filter(note => 
                            note.tags && note.tags.includes(filter.selectedTag)
                        );
                    }
                    
                    // åˆ†ç±»ç­›é€‰
                    if (filter.selectedCategory) {
                        filtered = filtered.filter(note => note.category === filter.selectedCategory);
                    }
                    
                    // å…³é”®è¯æœç´¢
                    if (filter.keyword) {
                        const keyword = filter.keyword.toLowerCase();
                        filtered = filtered.filter(note => 
                            note.title.toLowerCase().includes(keyword) || 
                            note.content.toLowerCase().includes(keyword) ||
                            (note.tags && note.tags.some(tag => tag.toLowerCase().includes(keyword)))
                        );
                    }
                    
                    // æ ¼å¼ç­›é€‰
                    if (filter.formatType) {
                        filtered = filtered.filter(note => {
                            if (!note.content) return false;
                            switch(filter.formatType) {
                                case 'highlight':
                                    return note.content.includes('class="highlight"') || 
                                           note.content.includes('<mark>') ||
                                           note.content.includes('background');
                                case 'bold':
                                    return note.content.includes('<b>') || 
                                           note.content.includes('<strong>');
                                case 'code':
                                    return note.content.includes('<code>') || 
                                           note.content.includes('<pre>');
                                case 'image':
                                    return note.content.includes('<img') || 
                                           note.imageData || 
                                           note.imageUrl;
                                default:
                                    return true;
                            }
                        });
                    }
                    
                    // æŒ‰æ—¶é—´å€’åºæ’åº
                    return filtered.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                });

                // ==================== è¾…åŠ©å‡½æ•° ====================
                const showStatusMessage = (text, type = 'info', duration = 5000) => {
                    statusMessage.value = { text, type };
                    if (duration > 0) {
                        setTimeout(() => {
                            statusMessage.value = null;
                        }, duration);
                    }
                };

                const getCategoryDisplayName = (cat) => {
                    return categoryDisplayNames[cat] || cat;
                };

                // HTMLå®‰å…¨è¿‡æ»¤
                const sanitizeHtml = (html) => {
                    if (!html) return '';
                    return html
                        .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
                        .replace(/on\w+="[^"]*"/g, '')
                        .replace(/on\w+='[^']*'/g, '')
                        .replace(/javascript:/gi, '');
                };

                // æ£€æŸ¥ç¬”è®°æ˜¯å¦æœ‰é«˜äº®
                const hasHighlights = (note) => {
                    if (!note.content) return false;
                    return note.content.includes('class="highlight"') || 
                           note.content.includes('<mark>') ||
                           note.content.includes('background-color');
                };

                // æ ¹æ®IDè·å–ç¬”è®°
                const getNoteById = (id) => {
                    return notes.value.find(note => note.id == id) || {};
                };

                // æ ¹æ®IDè·å–è¯»ä¹¦ç¬”è®°
                const getReadingNoteById = (id) => {
                    return readingNotes.value.find(note => note.id == id) || {};
                };

                // ä»ç°æœ‰ç¬”è®°ä¸­æå–æ‰€æœ‰åˆ†ç±»ï¼Œæ›´æ–°åˆ†ç±»åˆ—è¡¨
                const updateNoteCategoriesFromNotes = () => {
                    const categories = new Set(['all', 'editor', 'reading', 'mindmap', 'highlights', 'wordview']);
                    notes.value.forEach(note => {
                        if (note.category && note.category !== 'general') {
                            categories.add(note.category);
                        }
                    });
                    // ç¡®ä¿é»˜è®¤åˆ†ç±»ä¹Ÿå­˜åœ¨
                    Object.keys(categoryRules).forEach(cat => {
                        if (notes.value.some(n => n.category === cat) || 
                            notes.value.some(n => n.tags && n.tags.some(t => categoryRules[cat].some(k => t.includes(k))))) {
                            categories.add(cat);
                        }
                    });
                    noteCategories.value = Array.from(categories);
                };

                // æ ¹æ®æ ‡ç­¾æ™ºèƒ½åˆ¤æ–­åˆ†ç±»
                const determineCategoryFromTags = (tags) => {
                    for (const tag of tags) {
                        for (const [category, keywords] of Object.entries(categoryRules)) {
                            if (keywords.some(keyword => tag.toLowerCase().includes(keyword.toLowerCase()))) {
                                return category;
                            }
                        }
                    }
                    return 'general';
                };

                // æ–°å¢ï¼šé‡ç½®ç¬”è®°ç­›é€‰å™¨
                const resetNoteFilters = () => {
                    noteFilter.value = {
                        timeRange: 'all',
                        selectedTag: '',
                        selectedCategory: '',
                        keyword: '',
                        formatType: ''
                    };
                };

                // æ–°å¢ï¼šé‡ç½®è¯»ä¹¦ç¬”è®°ç­›é€‰å™¨
                const resetReadingFilters = () => {
                    readingFilter.value = {
                        keyword: '',
                        minRating: 0,
                        selectedTag: '',
                        sortBy: 'date'
                    };
                };

                // ==================== å¯Œæ–‡æœ¬ç¼–è¾‘åŠŸèƒ½ ====================
                const formatText = (command) => {
                    if (!richTextEditor.value) return;
                    
                    activeFormat.value = command;
                    const editor = richTextEditor.value;
                    
                    // ä¿å­˜å½“å‰é€‰åŒº
                    const selection = window.getSelection();
                    const range = selection.getRangeAt(0);
                    
                    // æ‰§è¡Œæ ¼å¼å‘½ä»¤
                    document.execCommand('styleWithCSS', false, true);
                    
                    switch(command) {
                        case 'bold':
                            document.execCommand('bold', false, null);
                            break;
                        case 'italic':
                            document.execCommand('italic', false, null);
                            break;
                        case 'underline':
                            document.execCommand('underline', false, null);
                            break;
                        case 'highlight':
                            // åˆ›å»ºé«˜äº®æ ·å¼
                            const span = document.createElement('span');
                            span.className = 'highlight';
                            span.style.backgroundColor = '#ffd6cc';
                            span.style.padding = '0 2px';
                            span.style.borderRadius = '2px';
                            try {
                                document.execCommand('insertHTML', false, span.outerHTML);
                            } catch (e) {
                                // å¦‚æœinsertHTMLå¤±è´¥ï¼Œç”¨å…¶ä»–æ–¹æ³•
                                range.surroundContents(span);
                            }
                            break;
                        case 'h1':
                            document.execCommand('formatBlock', false, '<h1>');
                            break;
                        case 'h2':
                            document.execCommand('formatBlock', false, '<h2>');
                            break;
                        case 'h3':
                            document.execCommand('formatBlock', false, '<h3>');
                            break;
                        case 'ul':
                            document.execCommand('insertUnorderedList', false, null);
                            break;
                        case 'ol':
                            document.execCommand('insertOrderedList', false, null);
                            break;
                        case 'blockquote':
                            document.execCommand('formatBlock', false, '<blockquote>');
                            break;
                    }
                    
                    // æ¢å¤ç„¦ç‚¹
                    editor.focus();
                    updateRichTextContent();
                };

                const changeTextColor = () => {
                    if (!richTextEditor.value) return;
                    document.execCommand('foreColor', false, textColor.value);
                    richTextEditor.value.focus();
                    updateRichTextContent();
                };

                const changeFontSize = () => {
                    if (!richTextEditor.value) return;
                    // è¿™é‡Œæˆ‘ä»¬é€šè¿‡CSSæ§åˆ¶æ•´ä½“å­—ä½“å¤§å°ï¼ŒexecCommandå¯¹å­—ä½“å¤§å°æ”¯æŒæœ‰é™
                    updateRichTextContent();
                };

                const insertCodeBlock = () => {
                    if (!richTextEditor.value) return;
                    
                    const codeBlock = `
                        <div class="code-block">
                            <pre><span class="keyword">function</span> <span class="function">example</span>() {
    <span class="comment">// è¿™é‡Œæ˜¯ä»£ç </span>
    <span class="keyword">const</span> <span class="variable">message</span> = <span class="string">"Hello World"</span>;
    <span class="function">console</span>.<span class="function">log</span>(<span class="variable">message</span>);
}</pre>
                        </div>
                    `;
                    
                    document.execCommand('insertHTML', false, codeBlock);
                    richTextEditor.value.focus();
                    updateRichTextContent();
                };

                const clearFormatting = () => {
                    if (!richTextEditor.value) return;
                    document.execCommand('removeFormat', false, null);
                    activeFormat.value = '';
                    richTextEditor.value.focus();
                    updateRichTextContent();
                };

                const updateRichTextContent = () => {
                    if (richTextEditor.value) {
                        newNote.value.content = richTextEditor.value.innerHTML;
                    }
                };

                const previewNote = () => {
                    const previewWindow = window.open('', '_blank');
                    previewWindow.document.write(`
                        <!DOCTYPE html>
                        <html>
                        <head>
                            <title>${newNote.value.title || 'ç¬”è®°é¢„è§ˆ'}</title>
                            <style>
                                body { font-family: 'Comic Neue', cursive; padding: 40px; max-width: 800px; margin: 0 auto; }
                                h1, h2, h3 { font-family: 'Gochi Hand', cursive; }
                                .highlight { background: #ffd6cc; padding: 0 2px; border-radius: 2px; }
                                blockquote { border-left: 4px solid #ff9a8b; padding-left: 20px; margin: 20px 0; font-style: italic; }
                            </style>
                        </head>
                        <body>
                            <h1>${newNote.value.title || 'æ— æ ‡é¢˜ç¬”è®°'}</h1>
                            <div>${newNote.value.content || ''}</div>
                        </body>
                        </html>
                    `);
                    previewWindow.document.close();
                };

                // ==================== è¯»ä¹¦ç¬”è®°åŠŸèƒ½ ====================
                const saveReadingNote = async () => {
                    if (!newReadingNote.value.title.trim() || !newReadingNote.value.author.trim()) {
                        showStatusMessage("è¯·å¡«å†™ä¹¦åå’Œä½œè€…", "error");
                        return;
                    }

                    const tags = newReadingNote.value.tagsInput
                        .split(',')
                        .map(tag => tag.trim())
                        .filter(tag => tag.length > 0);

                    const noteToSave = {
                        id: Date.now(),
                        title: newReadingNote.value.title,
                        author: newReadingNote.value.author,
                        notes: newReadingNote.value.notes,
                        reflections: newReadingNote.value.reflections,
                        rating: newReadingNote.value.rating || 0,
                        tags: tags,
                        createdAt: new Date().toISOString()
                    };

                    readingNotes.value.unshift(noteToSave);
                    
                    // æ›´æ–°é˜…è¯»ç›¸å…³çš„æˆå°±è¿›åº¦
                    updateReadingAchievements();

                    const saveSuccess = await saveGameDataToGitHub();
                    if (saveSuccess) {
                        clearReadingEditor();
                        showStatusMessage(`ğŸ“– è¯»ä¹¦ç¬”è®°"${noteToSave.title}"ä¿å­˜æˆåŠŸï¼`, "success", 5000);
                    }
                };

                const clearReadingEditor = () => {
                    newReadingNote.value = {
                        title: '',
                        author: '',
                        notes: '',
                        reflections: '',
                        rating: 0,
                        tagsInput: ''
                    };
                };

                const editReadingNote = (noteId) => {
                    const note = getReadingNoteById(noteId);
                    if (!note) return;
                    
                    editingReadingNote.value = {
                        ...note,
                        tagsInput: note.tags ? note.tags.join(', ') : ''
                    };
                    
                    // åˆ é™¤åŸç¬”è®°
                    const noteIndex = readingNotes.value.findIndex(n => n.id === noteId);
                    if (noteIndex !== -1) {
                        readingNotes.value.splice(noteIndex, 1);
                    }
                };

                const updateReadingNote = async () => {
                    if (!editingReadingNote.value) return;
                    
                    const tags = editingReadingNote.value.tagsInput
                        .split(',')
                        .map(tag => tag.trim())
                        .filter(tag => tag.length > 0);

                    const updatedNote = {
                        ...editingReadingNote.value,
                        tags: tags,
                        updatedAt: new Date().toISOString()
                    };
                    
                    // åˆ é™¤tagsInputå±æ€§
                    delete updatedNote.tagsInput;

                    readingNotes.value.unshift(updatedNote);
                    editingReadingNote.value = null;
                    
                    // æ›´æ–°é˜…è¯»ç›¸å…³çš„æˆå°±è¿›åº¦
                    updateReadingAchievements();

                    const saveSuccess = await saveGameDataToGitHub();
                    if (saveSuccess) {
                        showStatusMessage(`ğŸ“– è¯»ä¹¦ç¬”è®°"${updatedNote.title}"æ›´æ–°æˆåŠŸï¼`, "success");
                    }
                };

                const cancelEditReadingNote = () => {
                    if (editingReadingNote.value) {
                        // å°†ç¼–è¾‘ä¸­çš„ç¬”è®°é‡æ–°æ·»åŠ å›åˆ—è¡¨
                        const tags = editingReadingNote.value.tagsInput
                            .split(',')
                            .map(tag => tag.trim())
                            .filter(tag => tag.length > 0);
                        
                        const noteToRestore = {
                            ...editingReadingNote.value,
                            tags: tags
                        };
                        
                        delete noteToRestore.tagsInput;
                        
                        readingNotes.value.unshift(noteToRestore);
                        editingReadingNote.value = null;
                    }
                };

                const deleteReadingNote = async (noteId) => {
                    if (!confirm("ç¡®å®šè¦åˆ é™¤è¿™ç¯‡è¯»ä¹¦ç¬”è®°å—ï¼Ÿ")) return;
                    const noteIndex = readingNotes.value.findIndex(n => n.id === noteId);
                    if (noteIndex === -1) return;
                    
                    const deletedNote = readingNotes.value[noteIndex];
                    readingNotes.value.splice(noteIndex, 1);
                    
                    // æ›´æ–°é˜…è¯»ç›¸å…³çš„æˆå°±è¿›åº¦
                    updateReadingAchievements();
                    
                    await saveGameDataToGitHub();
                    showStatusMessage(`å·²åˆ é™¤è¯»ä¹¦ç¬”è®°"${deletedNote.title}"`, 'success');
                };

                const updateReadingAchievements = () => {
                    // æ›´æ–°é˜…è¯»ç›¸å…³çš„æˆå°±è¿›åº¦
                    const readingAchievements = achievements.value.filter(a => a.category === 'reading');
                    const totalReadingNotesCount = readingNotes.value.length;
                    
                    readingAchievements.forEach(achievement => {
                        achievement.current = Math.min(totalReadingNotesCount, achievement.requirement);
                        if (!achievement.unlocked && achievement.current >= achievement.requirement) {
                            achievement.unlocked = true;
                            player.value.xp += achievement.reward;
                            showStatusMessage(`ğŸ‰ æˆå°±è§£é”: ${achievement.name}! è·å¾— ${achievement.reward} XP`, 'success');
                            checkLevelUp();
                        }
                    });
                };

                // ==================== æ€ç»´å¯¼å›¾åŠŸèƒ½ï¼ˆå·²æ›´æ–°ï¼‰ ====================
                const getRandomNodeColor = () => {
                    const colors = [
                        '#fffefc', '#fffaf5', '#ffd6cc', '#ff9a8b', 
                        '#a3de83', '#4ecdc4', '#4a9fff', '#ffd166'
                    ];
                    return colors[Math.floor(Math.random() * colors.length)];
                };

                const addMindmapNode = () => {
                    if (!mindmapNodeText.value.trim()) return;
                    
                    const container = mindmapContainer.value;
                    if (!container) return;
                    
                    const centerX = container.clientWidth / 2;
                    const centerY = container.clientHeight / 2;
                    
                    let x, y;
                    if (mindmapNodes.value.length === 0) {
                        // ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ä½œä¸ºæ ¹èŠ‚ç‚¹
                        x = centerX - 60;
                        y = centerY - 30;
                        mindmapRootNode.value = Date.now();
                    } else if (mindmapSelectedNode.value) {
                        // ä½œä¸ºé€‰ä¸­èŠ‚ç‚¹çš„å­èŠ‚ç‚¹
                        const parentNode = mindmapNodes.value.find(n => n.id === mindmapSelectedNode.value);
                        if (parentNode) {
                            const angle = (parentNode.children?.length || 0) * 30 * (Math.PI / 180);
                            const radius = 120;
                            x = parentNode.x + Math.cos(angle) * radius;
                            y = parentNode.y + Math.sin(angle) * radius;
                        } else {
                            x = centerX + (Math.random() - 0.5) * 200;
                            y = centerY + (Math.random() - 0.5) * 200;
                        }
                    } else {
                        // éšæœºä½ç½®
                        const angle = (mindmapNodes.value.length * 45) * (Math.PI / 180);
                        const radius = 150;
                        x = centerX + Math.cos(angle) * radius - 60;
                        y = centerY + Math.sin(angle) * radius - 30;
                    }
                    
                    const nodeId = Date.now();
                    const newNode = {
                        id: nodeId,
                        text: mindmapNodeText.value.trim(),
                        x: x,
                        y: y,
                        color: getRandomNodeColor(),
                        parentId: mindmapSelectedNode.value,
                        children: [],
                        level: mindmapSelectedNode.value ? 
                            (mindmapNodes.value.find(n => n.id === mindmapSelectedNode.value)?.level || 0) + 1 : 0
                    };
                    
                    mindmapNodes.value.push(newNode);
                    
                    // å¦‚æœæ˜¯å­èŠ‚ç‚¹ï¼Œæ·»åŠ åˆ°çˆ¶èŠ‚ç‚¹çš„childrenä¸­
                    if (mindmapSelectedNode.value) {
                        const parentIndex = mindmapNodes.value.findIndex(n => n.id === mindmapSelectedNode.value);
                        if (parentIndex !== -1) {
                            if (!mindmapNodes.value[parentIndex].children) {
                                mindmapNodes.value[parentIndex].children = [];
                            }
                            mindmapNodes.value[parentIndex].children.push(nodeId);
                        }
                    }
                    
                    mindmapNodeText.value = '';
                    mindmapSelectedNode.value = nodeId;
                    
                    // æ›´æ–°è¿æ¥çº¿
                    updateMindmapLines();
                };

                const selectMindmapNode = (nodeId) => {
                    mindmapSelectedNode.value = nodeId;
                    if (nodeId) {
                        const node = mindmapNodes.value.find(n => n.id === nodeId);
                        if (node) {
                            showStatusMessage(`å·²é€‰æ‹©èŠ‚ç‚¹: ${node.text}`, 'info');
                        }
                    } else {
                        showStatusMessage('å·²å–æ¶ˆèŠ‚ç‚¹é€‰æ‹©', 'info');
                    }
                };

                const toggleRootNode = (nodeId) => {
                    if (mindmapRootNode.value === nodeId) {
                        mindmapRootNode.value = null;
                        showStatusMessage('å·²å–æ¶ˆæ ¹èŠ‚ç‚¹', 'info');
                    } else {
                        mindmapRootNode.value = nodeId;
                        showStatusMessage('å·²è®¾ç½®ä¸ºæ ¹èŠ‚ç‚¹', 'info');
                    }
                    updateMindmapLines();
                };

                const editMindmapNode = (index) => {
                    const newText = prompt('ç¼–è¾‘èŠ‚ç‚¹å†…å®¹:', mindmapNodes.value[index].text);
                    if (newText !== null) {
                        mindmapNodes.value[index].text = newText.trim();
                    }
                };

                const editMindmapNodeById = (nodeId) => {
                    const index = mindmapNodes.value.findIndex(n => n.id === nodeId);
                    if (index !== -1) {
                        editMindmapNode(index);
                    }
                };

                const removeMindmapNode = (index) => {
                    const node = mindmapNodes.value[index];
                    if (!confirm(`ç¡®å®šè¦åˆ é™¤èŠ‚ç‚¹"${node.text}"åŠå…¶æ‰€æœ‰å­èŠ‚ç‚¹å—ï¼Ÿ`)) return;
                    
                    // é€’å½’åˆ é™¤å­èŠ‚ç‚¹
                    const removeNodeAndChildren = (nodeId) => {
                        const nodeIndex = mindmapNodes.value.findIndex(n => n.id === nodeId);
                        if (nodeIndex !== -1) {
                            const node = mindmapNodes.value[nodeIndex];
                            if (node.children) {
                                node.children.forEach(childId => removeNodeAndChildren(childId));
                            }
                            mindmapNodes.value.splice(nodeIndex, 1);
                        }
                    };
                    
                    removeNodeAndChildren(node.id);
                    
                    // ä»çˆ¶èŠ‚ç‚¹çš„childrenä¸­åˆ é™¤
                    if (node.parentId) {
                        const parentIndex = mindmapNodes.value.findIndex(n => n.id === node.parentId);
                        if (parentIndex !== -1) {
                            const parent = mindmapNodes.value[parentIndex];
                            if (parent.children) {
                                parent.children = parent.children.filter(childId => childId !== node.id);
                            }
                        }
                    }
                    
                    // å¦‚æœåˆ é™¤çš„æ˜¯é€‰ä¸­èŠ‚ç‚¹ï¼Œå–æ¶ˆé€‰ä¸­
                    if (mindmapSelectedNode.value === node.id) {
                        mindmapSelectedNode.value = null;
                    }
                    
                    // å¦‚æœåˆ é™¤çš„æ˜¯æ ¹èŠ‚ç‚¹ï¼Œé‡æ–°é€‰æ‹©æ ¹èŠ‚ç‚¹
                    if (mindmapRootNode.value === node.id) {
                        mindmapRootNode.value = mindmapNodes.value.length > 0 ? mindmapNodes.value[0].id : null;
                    }
                    
                    updateMindmapLines();
                    showStatusMessage(`å·²åˆ é™¤èŠ‚ç‚¹: ${node.text}`, 'success');
                };

                const clearMindmap = () => {
                    if (!confirm("ç¡®å®šè¦æ¸…ç©ºæ•´ä¸ªæ€ç»´å¯¼å›¾å—ï¼Ÿ")) return;
                    mindmapNodes.value = [];
                    mindmapLines.value = [];
                    mindmapSelectedNode.value = null;
                    mindmapRootNode.value = null;
                    showStatusMessage('å·²æ¸…ç©ºæ€ç»´å¯¼å›¾', 'success');
                };

                const startNodeDrag = (node, event) => {
                    event.preventDefault();
                    draggingNode.value = node;
                    const rect = event.target.getBoundingClientRect();
                    dragOffset.value = {
                        x: event.clientX - rect.left,
                        y: event.clientY - rect.top
                    };
                    
                    const onMouseMove = (e) => {
                        if (draggingNode.value) {
                            const container = mindmapContainer.value;
                            if (!container) return;
                            
                            const containerRect = container.getBoundingClientRect();
                            const newX = e.clientX - containerRect.left - dragOffset.value.x;
                            const newY = e.clientY - containerRect.top - dragOffset.value.y;
                            
                            // ç¡®ä¿èŠ‚ç‚¹åœ¨å®¹å™¨å†…
                            const maxX = containerRect.width - 120;
                            const maxY = containerRect.height - 30;
                            
                            draggingNode.value.x = Math.max(0, Math.min(newX, maxX));
                            draggingNode.value.y = Math.max(0, Math.min(newY, maxY));
                            
                            updateMindmapLines();
                        }
                    };
                    
                    const onMouseUp = () => {
                        draggingNode.value = null;
                        window.removeEventListener('mousemove', onMouseMove);
                        window.removeEventListener('mouseup', onMouseUp);
                    };
                    
                    window.addEventListener('mousemove', onMouseMove);
                    window.addEventListener('mouseup', onMouseUp);
                };

                const updateMindmapLines = () => {
                    const lines = [];
                    mindmapNodes.value.forEach(node => {
                        // è¿æ¥åˆ°çˆ¶èŠ‚ç‚¹
                        if (node.parentId) {
                            const parent = mindmapNodes.value.find(n => n.id === node.parentId);
                            if (parent) {
                                lines.push({
                                    x1: parent.x + 60,
                                    y1: parent.y + 15,
                                    x2: node.x,
                                    y2: node.y + 15,
                                    type: 'parent-child'
                                });
                            }
                        }
                        
                        // è¿æ¥åˆ°æ ¹èŠ‚ç‚¹ï¼ˆå¦‚æœè®¾ç½®äº†æ ¹èŠ‚ç‚¹ï¼‰
                        if (mindmapRootNode.value && node.id !== mindmapRootNode.value) {
                            const rootNode = mindmapNodes.value.find(n => n.id === mindmapRootNode.value);
                            if (rootNode && !node.parentId) {
                                lines.push({
                                    x1: rootNode.x + 60,
                                    y1: rootNode.y + 15,
                                    x2: node.x + 60,
                                    y2: node.y + 15,
                                    type: 'root-connection'
                                });
                            }
                        }
                    });
                    mindmapLines.value = lines;
                };

                const addNodeAtPosition = (event) => {
                    if (!mindmapSelectedNode.value) return;
                    
                    const container = mindmapContainer.value;
                    if (!container) return;
                    
                    const rect = container.getBoundingClientRect();
                    const x = event.clientX - rect.left - 60;
                    const y = event.clientY - rect.top - 15;
                    
                    // ç¡®ä¿èŠ‚ç‚¹åœ¨å®¹å™¨å†…
                    const maxX = rect.width - 120;
                    const maxY = rect.height - 30;
                    
                    const newNode = {
                        id: Date.now(),
                        text: 'æ–°èŠ‚ç‚¹',
                        x: Math.max(0, Math.min(x, maxX)),
                        y: Math.max(0, Math.min(y, maxY)),
                        color: getRandomNodeColor(),
                        parentId: mindmapSelectedNode.value,
                        children: [],
                        level: mindmapNodes.value.find(n => n.id === mindmapSelectedNode.value)?.level + 1 || 1
                    };
                    
                    mindmapNodes.value.push(newNode);
                    
                    // æ·»åŠ åˆ°çˆ¶èŠ‚ç‚¹çš„childrenä¸­
                    const parentIndex = mindmapNodes.value.findIndex(n => n.id === mindmapSelectedNode.value);
                    if (parentIndex !== -1) {
                        if (!mindmapNodes.value[parentIndex].children) {
                            mindmapNodes.value[parentIndex].children = [];
                        }
                        mindmapNodes.value[parentIndex].children.push(newNode.id);
                    }
                    
                    mindmapSelectedNode.value = newNode.id;
                    updateMindmapLines();
                    showStatusMessage('åœ¨æŒ‡å®šä½ç½®æ·»åŠ äº†æ–°èŠ‚ç‚¹', 'success');
                };

                const saveMindmapAsNote = async () => {
                    if (mindmapNodes.value.length === 0) {
                        showStatusMessage('æ€ç»´å¯¼å›¾ä¸ºç©ºï¼Œæ— æ³•ä¿å­˜', 'error');
                        return;
                    }

                    const tags = ['æ€ç»´å¯¼å›¾', 'å¯è§†åŒ–'];
                    const category = 'mindmap';
                    
                    // æ„å»ºæ€ç»´å¯¼å›¾çš„æ–‡æœ¬è¡¨ç¤º
                    let content = '<h2>æ€ç»´å¯¼å›¾</h2>';
                    content += '<div style="background:#f9f5f0; padding:20px; border-radius:10px;">';
                    
                    // æ·»åŠ èŠ‚ç‚¹ä¿¡æ¯
                    content += '<h3>èŠ‚ç‚¹åˆ—è¡¨:</h3>';
                    content += '<ul>';
                    mindmapNodes.value.forEach(node => {
                        const parentName = node.parentId ? 
                            mindmapNodes.value.find(n => n.id === node.parentId)?.text || 'æœªçŸ¥' : 
                            'æ ¹èŠ‚ç‚¹';
                        content += `<li><strong>${node.text}</strong> (å±‚çº§: ${node.level}, çˆ¶èŠ‚ç‚¹: ${parentName})</li>`;
                    });
                    content += '</ul>';
                    
                    // æ·»åŠ ç»“æ„ä¿¡æ¯
                    if (mindmapRootNode.value) {
                        const rootNode = mindmapNodes.value.find(n => n.id === mindmapRootNode.value);
                        if (rootNode) {
                            content += `<h3>æ ¹èŠ‚ç‚¹: ${rootNode.text}</h3>`;
                        }
                    }
                    
                    content += '</div>';

                    const noteToSave = {
                        id: Date.now(),
                        title: `æ€ç»´å¯¼å›¾ - ${new Date().toLocaleDateString()}`,
                        content: content,
                        tags: tags,
                        category: category,
                        createdAt: new Date().toISOString(),
                        imageData: null,
                        imageUrl: null
                    };

                    notes.value.unshift(noteToSave);
                    
                    // æ›´æ–°åˆ†ç±»åˆ—è¡¨
                    updateNoteCategoriesFromNotes();

                    const saveSuccess = await saveGameDataToGitHub();
                    if (saveSuccess) {
                        showStatusMessage(`ğŸ’¾ æ€ç»´å¯¼å›¾å·²ä¿å­˜ä¸ºç¬”è®°"${noteToSave.title}"`, "success", 5000);
                        activeNoteTab.value = 'all';
                    }
                };

                const loadSampleMindmap = () => {
                    mindmapNodes.value = [
                        {
                            id: 1,
                            text: 'ä¸­å¿ƒä¸»é¢˜',
                            x: 300,
                            y: 250,
                            color: '#fffefc',
                            parentId: null,
                            children: [2, 3, 4],
                            level: 0
                        },
                        {
                            id: 2,
                            text: 'åˆ†æ”¯ä¸»é¢˜1',
                            x: 150,
                            y: 150,
                            color: '#ffd6cc',
                            parentId: 1,
                            children: [5],
                            level: 1
                        },
                        {
                            id: 3,
                            text: 'åˆ†æ”¯ä¸»é¢˜2',
                            x: 300,
                            y: 100,
                            color: '#a3de83',
                            parentId: 1,
                            children: [],
                            level: 1
                        },
                        {
                            id: 4,
                            text: 'åˆ†æ”¯ä¸»é¢˜3',
                            x: 450,
                            y: 150,
                            color: '#4ecdc4',
                            parentId: 1,
                            children: [6],
                            level: 1
                        },
                        {
                            id: 5,
                            text: 'å­ä¸»é¢˜1',
                            x: 100,
                            y: 50,
                            color: '#ff9a8b',
                            parentId: 2,
                            children: [],
                            level: 2
                        },
                        {
                            id: 6,
                            text: 'å­ä¸»é¢˜2',
                            x: 500,
                            y: 50,
                            color: '#4a9fff',
                            parentId: 4,
                            children: [],
                            level: 2
                        }
                    ];
                    
                    mindmapRootNode.value = 1;
                    mindmapSelectedNode.value = 1;
                    updateMindmapLines();
                    showStatusMessage('ç¤ºä¾‹æ€ç»´å¯¼å›¾å·²åŠ è½½', 'success');
                };

                // ==================== é«˜äº®å†…å®¹æå–åŠŸèƒ½ ====================
                const extractHighlights = () => {
                    if (!highlightSourceNote.value) {
                        showStatusMessage('è¯·é€‰æ‹©è¦æå–é«˜äº®çš„ç¬”è®°', 'error');
                        return;
                    }
                    
                    const note = getNoteById(highlightSourceNote.value);
                    if (!note) {
                        showStatusMessage('æœªæ‰¾åˆ°æŒ‡å®šç¬”è®°', 'error');
                        return;
                    }
                    
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = note.content;
                    
                    // æŸ¥æ‰¾æ‰€æœ‰é«˜äº®å…ƒç´ 
                    const highlightElements = tempDiv.querySelectorAll('.highlight, mark, [style*="background"], [class*="highlight"]');
                    
                    if (highlightElements.length === 0) {
                        showStatusMessage('è¯¥ç¬”è®°ä¸­æ²¡æœ‰æ‰¾åˆ°é«˜äº®å†…å®¹', 'warning');
                        return;
                    }
                    
                    highlightElements.forEach(element => {
                        extractedHighlights.value.push({
                            content: element.outerHTML || element.innerHTML,
                            sourceTitle: note.title,
                            sourceId: note.id
                        });
                    });
                    
                    // æ„å»ºæå–çš„å†…å®¹
                    newNoteFromHighlights.value = `<h2>æå–è‡ª: ${note.title}</h2>\n`;
                    highlightElements.forEach(element => {
                        newNoteFromHighlights.value += `<div style="background:#f9f5f0; padding:10px; margin:10px 0; border-left:4px solid #ff9a8b;">\n`;
                        newNoteFromHighlights.value += element.outerHTML || element.innerHTML;
                        newNoteFromHighlights.value += '\n</div>\n';
                    });
                    
                    showStatusMessage(`âœ… ä»"${note.title}"ä¸­æå–äº† ${highlightElements.length} ä¸ªé«˜äº®`, 'success');
                };

                const extractAllHighlights = () => {
                    extractedHighlights.value = [];
                    let totalHighlights = 0;
                    
                    notes.value.forEach(note => {
                        if (note.content) {
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = note.content;
                            
                            const highlightElements = tempDiv.querySelectorAll('.highlight, mark, [style*="background"], [class*="highlight"]');
                            
                            if (highlightElements.length > 0) {
                                highlightElements.forEach(element => {
                                    extractedHighlights.value.push({
                                        content: element.outerHTML || element.innerHTML,
                                        sourceTitle: note.title,
                                        sourceId: note.id
                                    });
                                });
                                totalHighlights += highlightElements.length;
                            }
                        }
                    });
                    
                    if (totalHighlights === 0) {
                        showStatusMessage('æ‰€æœ‰ç¬”è®°ä¸­éƒ½æ²¡æœ‰æ‰¾åˆ°é«˜äº®å†…å®¹', 'warning');
                    } else {
                        // æ„å»ºæå–çš„å†…å®¹
                        newNoteFromHighlights.value = `<h2>é«˜äº®å†…å®¹æ±‡æ€»</h2>\n<p>ä» ${notes.value.length} ç¯‡ç¬”è®°ä¸­æå–</p>\n`;
                        extractedHighlights.value.forEach(highlight => {
                            newNoteFromHighlights.value += `<div style="background:#f9f5f0; padding:10px; margin:10px 0; border-left:4px solid #ff9a8b;">\n`;
                            newNoteFromHighlights.value += `<p><small>æ¥æº: ${highlight.sourceTitle}</small></p>\n`;
                            newNoteFromHighlights.value += highlight.content;
                            newNoteFromHighlights.value += '\n</div>\n';
                        });
                        
                        showStatusMessage(`âœ… ä»æ‰€æœ‰ç¬”è®°ä¸­æå–äº† ${totalHighlights} ä¸ªé«˜äº®`, 'success');
                    }
                };

                const extractHighlightsFromNote = (noteId) => {
                    highlightSourceNote.value = noteId;
                    extractHighlights();
                };

                const createNoteFromHighlights = () => {
                    newNote.value.title = `é«˜äº®æ±‡æ€» - ${new Date().toLocaleDateString()}`;
                    newNote.value.content = newNoteFromHighlights.value;
                    newNote.value.tagsInput = 'é«˜äº®,æ±‡æ€»,ç²¾å';
                    activeNoteTab.value = 'editor';
                    
                    // è®¾ç½®å¯Œæ–‡æœ¬ç¼–è¾‘å™¨å†…å®¹
                    if (richTextEditor.value) {
                        richTextEditor.value.innerHTML = newNoteFromHighlights.value;
                        updateRichTextContent();
                    }
                    
                    showStatusMessage('é«˜äº®å†…å®¹å·²åŠ è½½åˆ°ç¼–è¾‘å™¨', 'success');
                };

                const saveHighlightsNote = async () => {
                    if (!newNoteFromHighlights.value.trim()) {
                        showStatusMessage('è¯·è¾“å…¥ç¬”è®°å†…å®¹', 'error');
                        return;
                    }

                    const tags = ['é«˜äº®æ±‡æ€»', 'ç²¾å'];
                    const category = 'highlights';
                    
                    const noteToSave = {
                        id: Date.now(),
                        title: `é«˜äº®æ±‡æ€» - ${new Date().toLocaleDateString()}`,
                        content: newNoteFromHighlights.value,
                        tags: tags,
                        category: category,
                        createdAt: new Date().toISOString(),
                        imageData: null,
                        imageUrl: null
                    };

                    notes.value.unshift(noteToSave);
                    
                    // æ›´æ–°åˆ†ç±»åˆ—è¡¨
                    updateNoteCategoriesFromNotes();

                    const saveSuccess = await saveGameDataToGitHub();
                    if (saveSuccess) {
                        showStatusMessage(`ğŸ’¾ é«˜äº®æ±‡æ€»å·²ä¿å­˜ä¸ºç¬”è®°"${noteToSave.title}"`, "success", 5000);
                        activeNoteTab.value = 'all';
                        clearHighlights();
                    }
                };

                const clearHighlights = () => {
                    extractedHighlights.value = [];
                    newNoteFromHighlights.value = '';
                    highlightSourceNote.value = '';
                };

                const copyHighlight = (highlight) => {
                    const textArea = document.createElement('textarea');
                    textArea.value = highlight.content.replace(/<[^>]*>/g, '');
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    showStatusMessage('é«˜äº®å†…å®¹å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success', 2000);
                };

                const removeHighlight = (index) => {
                    extractedHighlights.value.splice(index, 1);
                    showStatusMessage('å·²åˆ é™¤é«˜äº®', 'success');
                };

                // ==================== Wordé¢„è§ˆå’Œå¯¼å‡ºåŠŸèƒ½ ====================
                const printPreview = () => {
                    if (!selectedNoteForPreview.value) {
                        showStatusMessage('è¯·é€‰æ‹©è¦é¢„è§ˆçš„ç¬”è®°', 'error');
                        return;
                    }
                    
                    const note = getNoteById(selectedNoteForPreview.value);
                    if (!note) {
                        showStatusMessage('æœªæ‰¾åˆ°æŒ‡å®šç¬”è®°', 'error');
                        return;
                    }
                    
                    const printWindow = window.open('', '_blank');
                    printWindow.document.write(`
                        <!DOCTYPE html>
                        <html>
                        <head>
                            <title>${note.title} - æ‰“å°é¢„è§ˆ</title>
                            <style>
                                @media print {
                                    @page { margin: 2cm; }
                                }
                                body { 
                                    font-family: 'Times New Roman', serif; 
                                    padding: 40px; 
                                    max-width: 800px; 
                                    margin: 0 auto; 
                                    line-height: 1.6;
                                }
                                h1, h2, h3 { 
                                    font-family: 'Georgia', serif; 
                                    color: #333;
                                    page-break-after: avoid;
                                }
                                h1 { 
                                    font-size: 28px; 
                                    margin-bottom: 30px;
                                    text-align: center;
                                    border-bottom: 2px solid #333;
                                    padding-bottom: 15px;
                                }
                                h2 { font-size: 22px; margin-top: 30px; }
                                h3 { font-size: 18px; }
                                p { margin-bottom: 15px; }
                                .highlight { background: #ffffcc; padding: 0 2px; }
                                blockquote { 
                                    border-left: 4px solid #ccc; 
                                    padding-left: 20px; 
                                    margin: 20px 0; 
                                    font-style: italic;
                                    color: #555;
                                }
                                .code-block {
                                    background: #f5f5f5;
                                    border: 1px solid #ddd;
                                    padding: 15px;
                                    font-family: 'Courier New', monospace;
                                    font-size: 14px;
                                    margin: 20px 0;
                                    overflow-x: auto;
                                    white-space: pre-wrap;
                                }
                                .note-meta {
                                    color: #666;
                                    font-size: 14px;
                                    text-align: center;
                                    margin-bottom: 40px;
                                }
                                .page-break {
                                    page-break-before: always;
                                }
                            </style>
                        </head>
                        <body>
                            <div class="note-meta">
                                <p>${note.title}</p>
                                <p>åˆ›å»ºæ—¶é—´: ${formatDate(note.createdAt)}</p>
                            </div>
                            <div>${note.content}</div>
                            <div style="page-break-before: always;"></div>
                        </body>
                        </html>
                    `);
                    printWindow.document.close();
                    
                    // ç­‰å¾…å†…å®¹åŠ è½½åæ‰“å°
                    printWindow.onload = function() {
                        printWindow.focus();
                        printWindow.print();
                    };
                };

                const exportAsDocument = () => {
                    if (!selectedNoteForPreview.value) {
                        showStatusMessage('è¯·é€‰æ‹©è¦å¯¼å‡ºçš„ç¬”è®°', 'error');
                        return;
                    }
                    
                    const note = getNoteById(selectedNoteForPreview.value);
                    if (!note) {
                        showStatusMessage('æœªæ‰¾åˆ°æŒ‡å®šç¬”è®°', 'error');
                        return;
                    }
                    
                    // åˆ›å»ºHTMLå†…å®¹
                    const htmlContent = `
                        <!DOCTYPE html>
                        <html>
                        <head>
                            <meta charset="UTF-8">
                            <title>${note.title}</title>
                            <style>
                                body { 
                                    font-family: 'Times New Roman', serif; 
                                    padding: 40px; 
                                    max-width: 800px; 
                                    margin: 0 auto; 
                                    line-height: 1.6;
                                }
                                h1, h2, h3 { 
                                    font-family: 'Georgia', serif; 
                                    color: #333;
                                }
                                h1 { 
                                    font-size: 28px; 
                                    margin-bottom: 30px;
                                    text-align: center;
                                    border-bottom: 2px solid #333;
                                    padding-bottom: 15px;
                                }
                                h2 { font-size: 22px; margin-top: 30px; }
                                h3 { font-size: 18px; }
                                p { margin-bottom: 15px; }
                                .highlight { background: #ffffcc; padding: 0 2px; }
                                blockquote { 
                                    border-left: 4px solid #ccc; 
                                    padding-left: 20px; 
                                    margin: 20px 0; 
                                    font-style: italic;
                                    color: #555;
                                }
                                .code-block {
                                    background: #f5f5f5;
                                    border: 1px solid #ddd;
                                    padding: 15px;
                                    font-family: 'Courier New', monospace;
                                    font-size: 14px;
                                    margin: 20px 0;
                                    overflow-x: auto;
                                }
                                .note-meta {
                                    color: #666;
                                    font-size: 14px;
                                    text-align: center;
                                    margin-bottom: 40px;
                                }
                            </style>
                        </head>
                        <body>
                            <div class="note-meta">
                                <h1>${note.title}</h1>
                                <p>åˆ›å»ºæ—¶é—´: ${formatDate(note.createdAt)}</p>
                                ${note.tags && note.tags.length > 0 ? `<p>æ ‡ç­¾: ${note.tags.join(', ')}</p>` : ''}
                            </div>
                            <div>${note.content}</div>
                        </body>
                        </html>
                    `;
                    
                    // åˆ›å»ºä¸‹è½½é“¾æ¥
                    const blob = new Blob([htmlContent], { type: 'text/html' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${note.title.replace(/[^\w\s]/gi, '')}.html`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    showStatusMessage(`æ–‡æ¡£å·²å¯¼å‡º: ${a.download}`, 'success');
                };

                // ==================== ç¬”è®°ç¼–è¾‘åŠŸèƒ½ ====================
                const saveRichTextNote = async () => {
                    if (!newNote.value.title.trim()) {
                        showStatusMessage("è¯·å¡«å†™ç¬”è®°æ ‡é¢˜", "error");
                        return;
                    }

                    const tags = newNote.value.tagsInput
                        .split(',')
                        .map(tag => tag.trim())
                        .filter(tag => tag.length > 0);

                    const category = determineCategoryFromTags(tags);
                    
                    const noteToSave = {
                        id: Date.now(),
                        title: newNote.value.title,
                        content: newNote.value.content || '',
                        tags: tags,
                        category: category,
                        createdAt: new Date().toISOString(),
                        imageData: newNote.value.imageData,
                        imageUrl: null
                    };

                    notes.value.unshift(noteToSave);
                    
                    // æ›´æ–°åˆ†ç±»åˆ—è¡¨
                    updateNoteCategoriesFromNotes();

                    const saveSuccess = await saveGameDataToGitHub();
                    if (saveSuccess) {
                        clearNoteEditor();
                        showStatusMessage(`ğŸ’¾ ç¬”è®°"${noteToSave.title}"ä¿å­˜æˆåŠŸï¼`, "success", 5000);
                        activeNoteTab.value = 'all';
                    }
                };

                const clearNoteEditor = () => {
                    newNote.value = { 
                        title: '', 
                        content: '', 
                        tagsInput: '', 
                        imageData: null,
                        category: 'general' 
                    };
                    if (richTextEditor.value) {
                        richTextEditor.value.innerHTML = '';
                        updateRichTextContent();
                    }
                    activeFormat.value = '';
                    textColor.value = '#5a4a42';
                    fontSize.value = '16';
                };

                const editNote = (noteId) => {
                    const note = getNoteById(noteId);
                    if (!note) return;
                    
                    newNote.value = { 
                        title: note.title,
                        content: note.content || '',
                        tagsInput: note.tags ? note.tags.join(', ') : '',
                        imageData: note.imageData || note.imageUrl || null,
                        category: note.category || 'general'
                    };
                    
                    if (richTextEditor.value) {
                        richTextEditor.value.innerHTML = note.content || '';
                        updateRichTextContent();
                    }
                    
                    // åˆ é™¤åŸç¬”è®°
                    const noteIndex = notes.value.findIndex(n => n.id === noteId);
                    if (noteIndex !== -1) {
                        notes.value.splice(noteIndex, 1);
                    }
                    
                    activeNoteTab.value = 'editor';
                    showStatusMessage(`æ­£åœ¨ç¼–è¾‘ç¬”è®°: ${note.title}`, "info");
                };

                const deleteNote = async (noteId) => {
                    if (!confirm("ç¡®å®šè¦åˆ é™¤è¿™ç¯‡ç¬”è®°å—ï¼Ÿ")) return;
                    const noteIndex = notes.value.findIndex(n => n.id === noteId);
                    if (noteIndex === -1) return;
                    
                    const deletedNote = notes.value[noteIndex];
                    notes.value.splice(noteIndex, 1);
                    
                    await saveGameDataToGitHub();
                    showStatusMessage(`å·²åˆ é™¤ç¬”è®°"${deletedNote.title}"`, 'success');
                };

                const handleImageUpload = (event) => {
                    const file = event.target.files[0];
                    if (!file) return;

                    // æ£€æŸ¥æ–‡ä»¶å¤§å°ï¼ˆæœ€å¤§2MBï¼‰
                    if (file.size > 2 * 1024 * 1024) {
                        showStatusMessage('å›¾ç‰‡å¤§å°ä¸èƒ½è¶…è¿‡2MB', 'error');
                        return;
                    }

                    // æ£€æŸ¥æ–‡ä»¶ç±»å‹
                    const validTypes = ['image/jpeg', 'image/png', 'image/gif'];
                    if (!validTypes.includes(file.type)) {
                        showStatusMessage('ä»…æ”¯æŒ JPG, PNG, GIF æ ¼å¼', 'error');
                        return;
                    }

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        newNote.value.imageData = e.target.result;
                    };
                    reader.readAsDataURL(file);
                };

                const clearUploadedImage = () => {
                    newNote.value.imageData = null;
                };

                const handleImageError = (event) => {
                    event.target.style.display = 'none';
                    showStatusMessage('å›¾ç‰‡åŠ è½½å¤±è´¥', 'warning');
                };

                // ==================== æŠ€èƒ½ç³»ç»ŸåŠŸèƒ½ ====================
                const getSkillXpPerPractice = (skill) => {
                    return Math.max(1, Math.floor(skill.maxXp / 10));
                };

                const practiceSkill = async (skillId) => {
                    const skill = skills.value.find(s => s.id === skillId);
                    if (!skill) return;
                    
                    const xpGain = getSkillXpPerPractice(skill);
                    skill.xp += xpGain;
                    player.value.xp += Math.floor(xpGain / 2); // ç©å®¶è·å¾—ä¸€åŠç»éªŒ
                    
                    // æ£€æŸ¥æŠ€èƒ½å‡çº§
                    if (skill.xp >= skill.maxXp) {
                        skill.level++;
                        skill.xp = skill.xp - skill.maxXp;
                        skill.maxXp = Math.floor(skill.maxXp * 1.5);
                        showStatusMessage(`ğŸ‰ ${skill.name} å‡çº§åˆ° Lv.${skill.level}ï¼`, "success");
                        
                        // æ›´æ–°æŠ€èƒ½ç›¸å…³çš„æˆå°±
                        updateSkillAchievements();
                    }
                    
                    // æ£€æŸ¥ç©å®¶å‡çº§
                    checkLevelUp();
                    
                    // ä¿å­˜æ•°æ®
                    await saveGameDataToGitHub();
                    showStatusMessage(`ğŸ’ª ${skill.name} ç»ƒä¹ å®Œæˆï¼Œè·å¾— ${xpGain} XP`, "success");
                };

                const addNewSkill = () => {
                    const skillName = prompt('è¯·è¾“å…¥æ–°æŠ€èƒ½åç§°:');
                    if (!skillName || !skillName.trim()) return;
                    
                    const skillIcon = prompt('è¯·ä¸ºæŠ€èƒ½é€‰æ‹©ä¸€ä¸ªè¡¨æƒ…å›¾æ ‡ (ä¾‹å¦‚: ğŸ’ª, ğŸ§ , ğŸ¨):', 'ğŸ’ª') || 'ğŸ’ª';
                    const skillCategory = prompt('è¯·é€‰æ‹©æŠ€èƒ½ç±»åˆ« (ä¾‹å¦‚: å­¦ä¹ , å¥èº«, è‰ºæœ¯):', 'å­¦ä¹ ') || 'å­¦ä¹ ';
                    
                    const newSkill = {
                        id: Date.now(),
                        name: skillName.trim(),
                        icon: skillIcon,
                        category: skillCategory,
                        level: 1,
                        xp: 0,
                        maxXp: 100,
                        createdAt: new Date().toISOString()
                    };
                    
                    skills.value.unshift(newSkill);
                    showStatusMessage(`ğŸŒŸ æ–°æŠ€èƒ½"${skillName}"å·²æ·»åŠ ï¼`, "success");
                    
                    // æ›´æ–°æŠ€èƒ½ç›¸å…³çš„æˆå°±
                    updateSkillAchievements();
                };

                const deleteSkill = async (skillId) => {
                    if (!confirm("ç¡®å®šè¦åˆ é™¤è¿™ä¸ªæŠ€èƒ½å—ï¼Ÿ")) return;
                    const skillIndex = skills.value.findIndex(s => s.id === skillId);
                    if (skillIndex === -1) return;
                    
                    const deletedSkill = skills.value[skillIndex];
                    skills.value.splice(skillIndex, 1);
                    
                    await saveGameDataToGitHub();
                    showStatusMessage(`å·²åˆ é™¤æŠ€èƒ½"${deletedSkill.name}"`, 'success');
                };

                // ==================== æˆå°±ç³»ç»ŸåŠŸèƒ½ ====================
                const addBatchAchievements = () => {
                    try {
                        const achievementsToAdd = JSON.parse(batchAchievementInput.value);
                        if (!Array.isArray(achievementsToAdd)) {
                            showStatusMessage('è¯·è¾“å…¥æœ‰æ•ˆçš„JSONæ•°ç»„', 'error');
                            return;
                        }
                        
                        let addedCount = 0;
                        achievementsToAdd.forEach(achievement => {
                            const newId = Date.now() + Math.floor(Math.random() * 1000);
                            achievements.value.push({
                                id: newId,
                                category: achievement.category || 'custom',
                                name: achievement.name || 'æœªå‘½åæˆå°±',
                                icon: achievement.icon || 'ğŸ†',
                                description: achievement.description || 'è‡ªå®šä¹‰æˆå°±',
                                requirement: achievement.requirement || 1,
                                current: 0,
                                unlocked: false,
                                reward: achievement.reward || 50
                            });
                            addedCount++;
                        });
                        
                        showStatusMessage(`âœ… æˆåŠŸæ·»åŠ  ${addedCount} ä¸ªæˆå°±`, 'success');
                        batchAchievementInput.value = '';
                        showBatchAdd.value = false;
                    } catch (error) {
                        showStatusMessage('JSONæ ¼å¼é”™è¯¯: ' + error.message, 'error');
                    }
                };

                const loadExampleAchievements = () => {
                    batchAchievementInput.value = JSON.stringify([
                        {
                            "category": "custom",
                            "name": "æ—©èµ·è¾¾äºº",
                            "icon": "ğŸŒ…",
                            "description": "è¿ç»­30å¤©æ—©ä¸Š6ç‚¹å‰èµ·åºŠ",
                            "requirement": 30,
                            "reward": 150
                        },
                        {
                            "category": "custom",
                            "name": "è¯»ä¹¦ç ´ä¸‡å·",
                            "icon": "ğŸ“š",
                            "description": "è¯»å®Œ100æœ¬ä¹¦",
                            "requirement": 100,
                            "reward": 500
                        },
                        {
                            "category": "custom",
                            "name": "è¿åŠ¨å¥å°†",
                            "icon": "ğŸƒ",
                            "description": "å®Œæˆ1000å…¬é‡Œè·‘æ­¥",
                            "requirement": 1000,
                            "reward": 300
                        }
                    ], null, 2);
                    showStatusMessage('ç¤ºä¾‹æˆå°±å·²åŠ è½½', 'success');
                };

                const clearBatchInput = () => {
                    batchAchievementInput.value = '';
                };

                const deleteAchievement = async (achievementId) => {
                    if (!confirm("ç¡®å®šè¦åˆ é™¤è¿™ä¸ªæˆå°±å—ï¼Ÿ")) return;
                    const achievementIndex = achievements.value.findIndex(a => a.id === achievementId);
                    if (achievementIndex === -1) return;
                    
                    const deletedAchievement = achievements.value[achievementIndex];
                    achievements.value.splice(achievementIndex, 1);
                    
                    await saveGameDataToGitHub();
                    showStatusMessage(`å·²åˆ é™¤æˆå°±"${deletedAchievement.name}"`, 'success');
                };

                const updateSkillAchievements = () => {
                    // æ›´æ–°æŠ€èƒ½ç›¸å…³çš„æˆå°±
                    const skillAchievements = achievements.value.filter(a => a.category === 'skill');
                    
                    // å¤šé¢æ‰‹æˆå°±ï¼šæ‹¥æœ‰5ä¸ªä¸åŒæŠ€èƒ½
                    const multiSkillAchievement = skillAchievements.find(a => a.name === 'å¤šé¢æ‰‹');
                    if (multiSkillAchievement) {
                        multiSkillAchievement.current = skills.value.length;
                        if (!multiSkillAchievement.unlocked && multiSkillAchievement.current >= multiSkillAchievement.requirement) {
                            multiSkillAchievement.unlocked = true;
                            player.value.xp += multiSkillAchievement.reward;
                            showStatusMessage(`ğŸ‰ æˆå°±è§£é”: ${multiSkillAchievement.name}! è·å¾— ${multiSkillAchievement.reward} XP`, 'success');
                            checkLevelUp();
                        }
                    }
                    
                    // æŠ€èƒ½å¤§å¸ˆæˆå°±ï¼šæ‹¥æœ‰3ä¸ªè¾¾åˆ°5çº§çš„æŠ€èƒ½
                    const skillMasterAchievement = skillAchievements.find(a => a.name === 'æŠ€èƒ½å¤§å¸ˆ');
                    if (skillMasterAchievement) {
                        const highLevelSkills = skills.value.filter(s => s.level >= 5).length;
                        skillMasterAchievement.current = highLevelSkills;
                        if (!skillMasterAchievement.unlocked && skillMasterAchievement.current >= skillMasterAchievement.requirement) {
                            skillMasterAchievement.unlocked = true;
                            player.value.xp += skillMasterAchievement.reward;
                            showStatusMessage(`ğŸ‰ æˆå°±è§£é”: ${skillMasterAchievement.name}! è·å¾— ${skillMasterAchievement.reward} XP`, 'success');
                            checkLevelUp();
                        }
                    }
                };

                // ==================== ç­‰çº§ç³»ç»Ÿ ====================
                const checkLevelUp = () => {
                    while (player.value.xp >= player.value.nextLevelXp) {
                        player.value.xp -= player.value.nextLevelXp;
                        player.value.level++;
                        player.value.nextLevelXp = Math.floor(player.value.nextLevelXp * 1.2);
                        showStatusMessage(`ğŸ‰ æ­å–œå‡çº§åˆ° Lv.${player.value.level}ï¼`, "success", 3000);
                    }
                };

                // ==================== GitHub API åŠŸèƒ½ ====================
                const saveConfigAndLoad = async () => {
                    if (!config.value.username || !config.value.repo || !config.value.token) {
                        configError.value = 'è¯·å¡«å†™æ‰€æœ‰é…ç½®ä¿¡æ¯';
                        return;
                    }

                    isLoading.value = true;
                    configError.value = '';

                    try {
                        // æµ‹è¯•GitHubè¿æ¥
                        const testUrl = `https://api.github.com/repos/${config.value.username}/${config.value.repo}`;
                        const response = await fetch(testUrl, {
                            headers: {
                                'Authorization': `token ${config.value.token}`,
                                'Accept': 'application/vnd.github.v3+json'
                            }
                        });

                        if (!response.ok) {
                            if (response.status === 404) {
                                configError.value = 'ä»“åº“ä¸å­˜åœ¨ï¼Œè¯·å…ˆåˆ›å»ºä»“åº“';
                            } else if (response.status === 401) {
                                configError.value = 'Tokenæ— æ•ˆæˆ–æƒé™ä¸è¶³';
                            } else {
                                configError.value = `è¿æ¥å¤±è´¥: ${response.status} ${response.statusText}`;
                            }
                            isLoading.value = false;
                            return;
                        }

                        // ä¿å­˜é…ç½®åˆ°localStorage
                        localStorage.setItem('growth_notebook_config', JSON.stringify(config.value));
                        isConfigured.value = true;
                        
                        // åŠ è½½æ•°æ®
                        await loadGameDataFromGitHub();
                        
                    } catch (error) {
                        configError.value = `è¿æ¥é”™è¯¯: ${error.message}`;
                    } finally {
                        isLoading.value = false;
                    }
                };

                const loadGameDataFromGitHub = async () => {
                    isLoading.value = true;
                    
                    try {
                        const dataUrl = `https://api.github.com/repos/${config.value.username}/${config.value.repo}/contents/growth_data.json`;
                        const response = await fetch(dataUrl, {
                            headers: {
                                'Authorization': `token ${config.value.token}`,
                                'Accept': 'application/vnd.github.v3+json'
                            }
                        });

                        if (response.ok) {
                            const data = await response.json();
                            const content = JSON.parse(atob(data.content));
                            
                            player.value = content.player || { level: 1, xp: 0, nextLevelXp: 100, streak: 1 };
                            skills.value = content.skills || [];
                            notes.value = content.notes || [];
                            readingNotes.value = content.readingNotes || [];
                            achievements.value = content.achievements || achievements.value;
                            
                            // æ›´æ–°åˆ†ç±»åˆ—è¡¨
                            updateNoteCategoriesFromNotes();
                            
                            showStatusMessage('âœ… æ•°æ®åŠ è½½æˆåŠŸ', 'success');
                        } else {
                            // æ–‡ä»¶ä¸å­˜åœ¨ï¼Œä½¿ç”¨é»˜è®¤æ•°æ®
                            showStatusMessage('ğŸ“ åˆ›å»ºæ–°çš„æ‰‹è´¦æ•°æ®æ–‡ä»¶', 'info');
                            await saveGameDataToGitHub();
                        }
                        
                        lastSyncTime.value = new Date().toLocaleTimeString();
                        
                    } catch (error) {
                        showStatusMessage(`åŠ è½½æ•°æ®å¤±è´¥: ${error.message}`, 'error');
                    } finally {
                        isLoading.value = false;
                    }
                };

                const saveGameDataToGitHub = async () => {
                    isSaving.value = true;
                    
                    try {
                        // å‡†å¤‡æ•°æ®
                        const gameData = {
                            player: player.value,
                            skills: skills.value,
                            notes: notes.value,
                            readingNotes: readingNotes.value,
                            achievements: achievements.value,
                            lastUpdated: new Date().toISOString()
                        };

                        const content = JSON.stringify(gameData, null, 2);
                        const contentBase64 = btoa(unescape(encodeURIComponent(content)));
                        
                        // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
                        const dataUrl = `https://api.github.com/repos/${config.value.username}/${config.value.repo}/contents/growth_data.json`;
                        let sha = null;
                        
                        try {
                            const checkResponse = await fetch(dataUrl, {
                                headers: {
                                    'Authorization': `token ${config.value.token}`,
                                    'Accept': 'application/vnd.github.v3+json'
                                }
                            });
                            
                            if (checkResponse.ok) {
                                const existingData = await checkResponse.json();
                                sha = existingData.sha;
                            }
                        } catch (e) {
                            // æ–‡ä»¶ä¸å­˜åœ¨ï¼Œæ­£å¸¸åˆ›å»º
                        }

                        // åˆ›å»ºæˆ–æ›´æ–°æ–‡ä»¶
                        const updateResponse = await fetch(dataUrl, {
                            method: 'PUT',
                            headers: {
                                'Authorization': `token ${config.value.token}`,
                                'Accept': 'application/vnd.github.v3+json',
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                message: `æ›´æ–°æ‰‹è´¦æ•°æ® ${new Date().toLocaleString()}`,
                                content: contentBase64,
                                sha: sha
                            })
                        });

                        if (updateResponse.ok) {
                            lastSyncTime.value = new Date().toLocaleTimeString();
                            showStatusMessage('ğŸ’¾ æ•°æ®ä¿å­˜æˆåŠŸ', 'success', 3000);
                            return true;
                        } else {
                            const error = await updateResponse.json();
                            showStatusMessage(`ä¿å­˜å¤±è´¥: ${error.message}`, 'error');
                            return false;
                        }
                        
                    } catch (error) {
                        showStatusMessage(`ä¿å­˜å¤±è´¥: ${error.message}`, 'error');
                        return false;
                    } finally {
                        isSaving.value = false;
                    }
                };

                const forceLoadFromGitHub = async () => {
                    await loadGameDataFromGitHub();
                };

                const forceSaveToGitHub = async () => {
                    await saveGameDataToGitHub();
                };

                const openRepoInGitHub = () => {
                    window.open(`https://github.com/${config.value.username}/${config.value.repo}`, '_blank');
                };

                // ==================== æ•°æ®å¯¼å…¥å¯¼å‡º ====================
                const exportLocalData = () => {
                    const gameData = {
                        player: player.value,
                        skills: skills.value,
                        notes: notes.value,
                        readingNotes: readingNotes.value,
                        achievements: achievements.value,
                        config: config.value,
                        exportedAt: new Date().toISOString()
                    };

                    const dataStr = JSON.stringify(gameData, null, 2);
                    const dataBlob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(dataBlob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `growth_notebook_backup_${new Date().toISOString().split('T')[0]}.json`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                    
                    showStatusMessage('ğŸ“¦ æ•°æ®å¤‡ä»½å·²å¯¼å‡º', 'success');
                };

                const importLocalData = (event) => {
                    const file = event.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const importedData = JSON.parse(e.target.result);
                            
                            if (importedData.player) player.value = importedData.player;
                            if (importedData.skills) skills.value = importedData.skills;
                            if (importedData.notes) notes.value = importedData.notes;
                            if (importedData.readingNotes) readingNotes.value = importedData.readingNotes;
                            if (importedData.achievements) achievements.value = importedData.achievements;
                            
                            // æ›´æ–°åˆ†ç±»åˆ—è¡¨
                            updateNoteCategoriesFromNotes();
                            
                            // ä¿å­˜åˆ°GitHub
                            await saveGameDataToGitHub();
                            
                            showStatusMessage('ğŸ“¥ æ•°æ®å¯¼å…¥æˆåŠŸ', 'success');
                            showImport.value = false;
                        } catch (error) {
                            showStatusMessage(`å¯¼å…¥å¤±è´¥: ${error.message}`, 'error');
                        }
                    };
                    reader.readAsText(file);
                };

                // ==================== æ¼”ç¤ºæ•°æ® ====================
                const loadDemoData = () => {
                    player.value = { level: 3, xp: 75, nextLevelXp: 200, streak: 7 };
                    
                    skills.value = [
                        { id: 1, name: 'å…«å­—å‘½ç†', icon: 'ğŸŒŒ', category: 'æ˜“å­¦', level: 2, xp: 60, maxXp: 150, createdAt: '2024-01-15T10:30:00Z' },
                        { id: 2, name: 'è‹±è¯­é˜…è¯»', icon: 'ğŸ“š', category: 'è‹±è¯­', level: 1, xp: 30, maxXp: 100, createdAt: '2024-01-20T14:45:00Z' },
                        { id: 3, name: 'å¥èº«è®­ç»ƒ', icon: 'ğŸ’ª', category: 'å¥èº«', level: 1, xp: 80, maxXp: 100, createdAt: '2024-01-25T08:15:00Z' }
                    ];
                    
                    notes.value = [
                        {
                            id: 1,
                            title: 'å…«å­—åŸºç¡€çŸ¥è¯†æ€»ç»“',
                            content: '<h2>å…«å­—åŸºç¡€çŸ¥è¯†</h2><p>å…«å­—åˆç§°<strong>å››æŸ±</strong>ï¼Œç”±å¹´ã€æœˆã€æ—¥ã€æ—¶å››æŸ±ç»„æˆï¼Œæ¯æŸ±ä¸¤ä¸ªå­—ï¼Œå…±å…«ä¸ªå­—ã€‚</p><p class="highlight">æ ¸å¿ƒæ¦‚å¿µï¼šå¤©å¹²åœ°æ”¯ã€äº”è¡Œç”Ÿå…‹ã€åç¥å…³ç³»</p>',
                            tags: ['å…«å­—', 'å‘½ç†', 'å­¦ä¹ ç¬”è®°'],
                            category: 'bazi',
                            createdAt: '2024-01-15T10:30:00Z'
                        },
                        {
                            id: 2,
                            title: 'è‚¡ç¥¨å¤ç›˜ç¬”è®°',
                            content: '<h3>ä»Šæ—¥å¤§ç›˜åˆ†æ</h3><p>ä¸Šè¯æŒ‡æ•°æ”¶äº3000ç‚¹ï¼Œæ¶¨å¹…0.5%ã€‚<span class="highlight">é‡ç‚¹å…³æ³¨ç§‘æŠ€æ¿å—</span>ï¼Œäººå·¥æ™ºèƒ½æ¦‚å¿µæŒç»­èµ°å¼ºã€‚</p>',
                            tags: ['è‚¡ç¥¨', 'å¤ç›˜', 'æŠ•èµ„'],
                            category: 'stock',
                            createdAt: '2024-01-20T14:45:00Z'
                        }
                    ];
                    
                    readingNotes.value = [
                        {
                            id: 1,
                            title: 'æ€è€ƒï¼Œå¿«ä¸æ…¢',
                            author: 'ä¸¹å°¼å°”Â·å¡å°¼æ›¼',
                            notes: 'æœ¬ä¹¦ä»‹ç»äº†å¤§è„‘çš„ä¸¤å¥—ç³»ç»Ÿï¼šç³»ç»Ÿ1ï¼ˆå¿«é€Ÿã€ç›´è§‰ï¼‰å’Œç³»ç»Ÿ2ï¼ˆç¼“æ…¢ã€ç†æ€§ï¼‰',
                            reflections: 'è®©æˆ‘æ›´åŠ æ„è¯†åˆ°æ—¥å¸¸å†³ç­–ä¸­çš„è®¤çŸ¥åè§ï¼Œéœ€è¦æ›´å¤šè°ƒç”¨ç³»ç»Ÿ2æ€è€ƒ',
                            rating: 5,
                            tags: ['å¿ƒç†å­¦', 'è®¤çŸ¥ç§‘å­¦', 'è¡Œä¸ºç»æµå­¦'],
                            createdAt: '2024-01-10T09:00:00Z'
                        }
                    ];
                    
                    // æ›´æ–°ä¸€äº›æˆå°±è¿›åº¦
                    achievements.value.forEach(achievement => {
                        if (achievement.category === 'skill') {
                            achievement.current = skills.value.length;
                        }
                        if (achievement.category === 'reading') {
                            achievement.current = readingNotes.value.length;
                        }
                        if (achievement.category === 'fitness') {
                            achievement.current = 15; // å‡è®¾å®Œæˆäº†15æ¬¡å¥èº«
                        }
                    });
                    
                    // æ›´æ–°åˆ†ç±»åˆ—è¡¨
                    updateNoteCategoriesFromNotes();
                    
                    isConfigured.value = true;
                    showStatusMessage('ğŸ® æ¼”ç¤ºæ•°æ®åŠ è½½å®Œæˆ', 'success');
                };

                // ==================== å·¥å…·å‡½æ•° ====================
                const formatDate = (dateString) => {
                    const date = new Date(dateString);
                    return date.toLocaleDateString('zh-CN', { 
                        year: 'numeric', 
                        month: '2-digit', 
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                };

                const resetData = () => {
                    if (!confirm("âš ï¸ è­¦å‘Šï¼šè¿™å°†é‡ç½®æ‰€æœ‰æ•°æ®ï¼ŒåŒ…æ‹¬æŠ€èƒ½ã€ç¬”è®°å’Œæˆå°±ã€‚ç¡®å®šè¦é‡ç½®å—ï¼Ÿ")) {
                        return;
                    }
                    
                    player.value = { level: 1, xp: 0, nextLevelXp: 100, streak: 1 };
                    skills.value = [];
                    notes.value = [];
                    readingNotes.value = [];
                    achievements.value.forEach(achievement => {
                        achievement.current = 0;
                        achievement.unlocked = false;
                    });
                    
                    showStatusMessage('ğŸ”„ æ‰€æœ‰æ•°æ®å·²é‡ç½®', 'success');
                };

                // ==================== åˆå§‹åŒ– ====================
                onMounted(() => {
                    // å°è¯•ä»localStorageåŠ è½½é…ç½®
                    const savedConfig = localStorage.getItem('growth_notebook_config');
                    if (savedConfig) {
                        try {
                            config.value = JSON.parse(savedConfig);
                            isConfigured.value = true;
                            
                            // è‡ªåŠ¨åŠ è½½æ•°æ®
                            loadGameDataFromGitHub();
                        } catch (e) {
                            console.log('æ— æ³•åŠ è½½ä¿å­˜çš„é…ç½®');
                        }
                    }
                    
                    // åˆå§‹åŒ–æ€ç»´å¯¼å›¾å®¹å™¨äº‹ä»¶
                    if (mindmapContainer.value) {
                        updateMindmapLines();
                    }
                });

                // ==================== æš´éœ²ç»™æ¨¡æ¿ ====================
                return {
                    // çŠ¶æ€
                    isConfigured,
                    showConfig,
                    showImport,
                    isSaving,
                    isLoading,
                    configError,
                    lastSyncTime,
                    statusMessage,
                    config,
                    player,
                    skills,
                    notes,
                    readingNotes,
                    activeAchievementTab,
                    activeNoteTab,
                    noteCategories,
                    newNote,
                    newReadingNote,
                    editingReadingNote,
                    readingFilter,
                    collapseStatus,
                    collapseSkills,
                    collapseAchievements,
                    collapseNotes,
                    showBatchAdd,
                    batchAchievementInput,
                    editorFocused,
                    activeFormat,
                    textColor,
                    fontSize,
                    richTextEditor,
                    mindmapNodeText,
                    mindmapNodes,
                    mindmapLines,
                    mindmapContainer,
                    mindmapSelectedNode,
                    mindmapRootNode,
                    extractedHighlights,
                    highlightSourceNote,
                    newNoteFromHighlights,
                    selectedNoteForPreview,
                    noteFilter,
                    achievements,
                    
                    // è®¡ç®—å±æ€§
                    totalXpEarned,
                    totalSkills,
                    totalNotes,
                    totalReadingNotes,
                    completedAchievementsCount,
                    totalHighlights,
                    allNoteTags,
                    readingTags,
                    totalAuthors,
                    averageRating,
                    filteredReadingNotes,
                    filteredAchievements,
                    filteredAndSortedNotes,
                    
                    // æ–¹æ³•
                    showStatusMessage,
                    getCategoryDisplayName,
                    sanitizeHtml,
                    hasHighlights,
                    getNoteById,
                    getReadingNoteById,
                    resetNoteFilters,
                    resetReadingFilters,
                    formatText,
                    changeTextColor,
                    changeFontSize,
                    insertCodeBlock,
                    clearFormatting,
                    updateRichTextContent,
                    previewNote,
                    saveReadingNote,
                    clearReadingEditor,
                    editReadingNote,
                    updateReadingNote,
                    cancelEditReadingNote,
                    deleteReadingNote,
                    addMindmapNode,
                    selectMindmapNode,
                    toggleRootNode,
                    editMindmapNode,
                    editMindmapNodeById,
                    removeMindmapNode,
                    clearMindmap,
                    startNodeDrag,
                    addNodeAtPosition,
                    saveMindmapAsNote,
                    loadSampleMindmap,
                    extractHighlights,
                    extractAllHighlights,
                    extractHighlightsFromNote,
                    createNoteFromHighlights,
                    saveHighlightsNote,
                    clearHighlights,
                    copyHighlight,
                    removeHighlight,
                    printPreview,
                    exportAsDocument,
                    saveRichTextNote,
                    clearNoteEditor,
                    editNote,
                    deleteNote,
                    handleImageUpload,
                    clearUploadedImage,
                    handleImageError,
                    getSkillXpPerPractice,
                    practiceSkill,
                    addNewSkill,
                    deleteSkill,
                    addBatchAchievements,
                    loadExampleAchievements,
                    clearBatchInput,
                    deleteAchievement,
                    checkLevelUp,
                    saveConfigAndLoad,
                    forceLoadFromGitHub,
                    forceSaveToGitHub,
                    openRepoInGitHub,
                    exportLocalData,
                    importLocalData,
                    loadDemoData,
                    formatDate,
                    resetData
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
